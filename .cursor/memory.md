# ポートフォリオサイト開発の重要な記憶

このファイルはポートフォリオサイト開発における重要な記憶を保存するためのものです。LLMセッションが切れた後も、プロジェクトの知識と実装パターンを引き継ぐために使用されます。新しい開発を始める前に必ずこのファイルを参照し、プロジェクトの一貫性を保つようにしてください。新しい知見や重要な実装パターンを発見した場合は、このファイルに追加することを検討してください。

## 目次

1. [LLMとしての対応方針](#llmとしての対応方針)
2. [プロジェクト構造](#プロジェクト構造に関する記憶)
3. [コーディングパターン](#コーディングパターンの記憶)
4. [テスト関連](#テスト関連の記憶)
5. [コンポーネントディレクトリ構造](#コンポーネントのディレクトリ構造改善に関する記憶)
6. [コード品質とリント](#リントチェックとコード品質の維持)
7. [デプロイ関連](#デプロイ関連の記憶)
8. [特定の実装](#特定の実装に関する記憶)
9. [問題と解決策](#開発中に遭遇した問題と解決策)
10. [次のステップ](#次のステップ)
11. [ディレクトリ構造の移行](#ディレクトリ構造の移行)

## LLMとしての対応方針

1. **コード実装前の準備**

   - 既存のソースコードと.cursor/rules, .cursor/memory, .cursor/promptを読み込み、プロジェクトの構造と規約、あなたの役割を理解
   - 実装プランを立て、タスクを細分化

2. **コード品質の確保**

   - 実装後にコードの正確性を確認
   - リファクタリングの余地がある場合は改善を提案
   - コードの重複を避け、共通化を推進

3. **コミュニケーション**

   - 常に日本語で応答
   - 技術的な説明も日本語で行う
   - 指摘事項は.cursor/rulesに反映してナレッジを蓄積

4. **記憶の管理**
   - あなたのタスクが完了するごとに必ず.cursor/memoryを更新する
   - 記憶を読み込んだ後に不要な記述や重複箇所があれば記憶を整理しても良いが必ずコンテキストが損なわれる変更はしない
   - 記憶を管理する際に日付を入れない（具体的な年月日を記載しない）
   - これ以降の記述は古い順に書いてあるものである（更新する際も必ず後ろに追加する）
   - セッションが切れそうだと感じたら現在のタスクを終了し.cursor/memoryを更新し整理して次のセッションに移行することをユーザーに提案してください

## プロジェクト構造に関する記憶

1. **アトミックデザインの実装**

   - `src/components/`以下に`atoms/`, `molecules/`, `organisms/`, `templates/`, `pages/`の階層構造を採用
   - 各コンポーネントは責任範囲を明確にし、再利用性を高めるように設計
   - 特に`atoms`コンポーネントは最小単位のUI要素として、多くの場所で再利用されている
   - アトミックデザインの階層構造を厳守し、上位のコンポーネントが下位のコンポーネントを使用する形を維持する
   - 具体的には、organisms → molecules → atoms の依存方向を守り、逆方向の依存（molecules → organisms）は避ける
   - コンポーネントの責任範囲と複雑さに基づいて適切なカテゴリに分類する
     - atoms: ボタン、入力フィールド、アイコンなどの最小単位のUI要素
     - molecules: 複数のatomsを組み合わせた小さな機能単位（検索フォーム、ナビゲーションリンクグループなど）
     - organisms: 複数のmoleculesとatomsを組み合わせた機能的なセクション（ヘッダー、フッター、コンタクトフォームなど）
     - templates: ページのレイアウト構造を定義
     - pages: 完全なページコンポーネント

2. **App Routerの活用**

   - `src/app/`以下にNext.jsのApp Routerパターンを採用
   - 各ページは`page.tsx`として実装し、共通レイアウトは`layout.tsx`で管理
   - エラー処理は`error.tsx`、ローディング状態は`loading.tsx`で統一的に実装

3. **型定義の集中管理**
   - `src/types/`ディレクトリで型定義を集中管理
   - コンポーネント間で共有される型は共通モジュールとして定義
   - 型安全性を確保するため、`any`型の使用を避け、明示的な型定義を徹底

## コーディングパターンの記憶

1. **条件付きレンダリングのパターン**

   ```tsx
   {
     isTopPage ? <NavigationMenu /> : <BackButton />;
   }
   ```

   - 条件によって表示/非表示を切り替える場合は、上記のパターンを使用
   - 特にナビゲーションメニューはトップページでのみ表示するルールを採用

2. **スタイリングの一貫性**

   ```tsx
   <div className={cn(
     "bg-gray-900/80 p-4 rounded-lg",
     "hover:bg-gray-800/90 transition-colors",
     className
   )}>
   ```

   - Tailwindのユーティリティクラスを`cn()`関数でグループ化
   - 背景色は暗めの色調、アクセント色は青系統を基本とする
   - コンポーネント間で視覚的な一貫性を保つよう注意

3. **エラーハンドリングパターン**

   ```tsx
   try {
     // 処理
   } catch (error) {
     console.error("エラーが発生しました:", error);
     return <ErrorComponent message="エラーが発生しました" />;
   }
   ```

   - エラー発生時は適切なエラーメッセージを表示
   - ユーザーフレンドリーなエラー表示を心がける

4. **データフェッチングパターン**
   ```tsx
   // サーバーコンポーネントでのデータフェッチ
   const data = await fetch("/api/data", { next: { revalidate: 3600 } }).then(
     (res) => res.json()
   );
   ```
   - 可能な限りサーバーコンポーネントでデータフェッチングを実施
   - 適切なキャッシュ戦略を設定

## テスト関連の記憶

1. **アイコンコンポーネントのモック**

   - `jest.setup.js`でLucide Reactなどのアイコンコンポーネントをモック化
   - 新しいアイコンを追加した場合は、必ずモックも追加する
   - テスト失敗の多くはアイコンモックの不足が原因だった

2. **テストの安定性向上**

   - レンダリングテストでは`data-testid`属性を活用
   - 非同期処理を含むテストでは`waitFor`や`findBy*`クエリを使用
   - スナップショットテストは変更が少ないコンポーネントに限定
   - 複雑なテキスト（改行を含む）は正規表現を使用して部分一致で検索する
   - セクション要素の取得は`getByRole("region")`よりも`getElementById()`の方が安定することがある
   - モックは個別のテストファイルではなく`jest.setup.js`で一元管理する

3. **モックの一元管理**

   - すべてのモックは`jest.setup.js`で一元管理し、個別のテストファイルでモックを定義しない
   - 個別のテストファイルでの以下のモックパターンを禁止:
     - `jest.mock()`の使用
     - `jest.spyOn()`の使用
     - `jest-mock-extended`のインポート
   - モックが必要な場合は`jest.setup.js`に追加し、テストファイルではそれを利用する
   - 一元管理により、モックの一貫性が保たれ、メンテナンス性が向上する
   - 新しいモックを追加する際は、既存のモックパターンに従う
   - ESLintルールを使用して、個別のテストファイルでのモック定義を禁止する
   - モックの一元管理により以下のメリットが得られる:
     - モックの重複を排除
     - モックの一貫性を確保
     - テストの安定性向上
     - メンテナンス性の向上
     - モックの変更が必要な場合、一箇所の変更で全テストに反映される

4. **コンポーネント移動時のテスト対応**

   - コンポーネントを移動する際は、必ず対応するテストファイルも移動する
   - テストファイルのインポートパスも更新する
   - テストファイルの移動後、必ず`yarn test <テストファイル名>`を実行して動作確認する
   - テスト失敗時は、テキスト検索の問題（改行など）や要素の取得方法（role vs id）を確認する
   - コンポーネント移動後は全テスト（`yarn test`）とビルド（`yarn build`）を実行して問題がないことを確認する

5. **テスト実行のルール**

   - コンポーネントの変更後は必ず対応するテストを実行する
   - 構造的な変更（ディレクトリ移動など）後は全テストを実行する
   - ビルド前に全テストを実行し、問題がないことを確認する
   - テスト失敗時は、コンポーネントとテストの両方を確認し、どちらを修正すべきか判断する
   - テストの修正はコンポーネントの意図を変えないように注意する

6. **テスト環境の設定とモックの改善**
   - `jest.setup.js`でFramer Motionライブラリを包括的にモック化
   - `motion`コンポーネントの各HTML要素（div, h1, h2, p, spanなど）を個別にモック
   - `useRouter`, `usePathname`, `useSearchParams`などのNext.jsフックをモック
   - Buttonなどの共通UIコンポーネントは`data-testid`属性を持つシンプルな要素にモック
   - 複雑なUIコンポーネント（Card, Badge）は入れ子構造を保持しつつシンプル化
   - 共通のモックは`jest.setup.js`で一元管理し、テスト固有のモックはテストファイル内でローカルに定義

## コンポーネントのディレクトリ構造改善に関する記憶

1. **コンポーネントのディレクトリ構造の標準化**

   - 各コンポーネントは独自のディレクトリを持ち、その中に実装ファイル、テストファイル、インデックスファイルを配置する構造に統一

   ```
   src/components/atoms/
     └── ComponentName/
         ├── ComponentName.tsx    # コンポーネント実装
         ├── ComponentName.test.tsx    # テスト
         └── index.ts             # エクスポート定義
   ```

   - この構造により、関連ファイルが一箇所に集約され、コンポーネントの移動や管理が容易になる
   - インデックスファイルを使用することで、インポートパスをシンプルに保ちながら内部実装の詳細を隠蔽できる

2. **コンポーネントのエクスポートとインポートのルール**

   - コンポーネントファイル内では名前付きエクスポートとデフォルトエクスポートの両方を提供する

   ```tsx
   export const ComponentName = () => {
     /* ... */
   };
   export default ComponentName;
   ```

   - index.tsファイルでは両方のエクスポート方法をサポートする

   ```tsx
   export { default, ComponentName } from "./ComponentName";
   ```

   - これにより、名前付きインポートとデフォルトインポートの両方が機能する

   ```tsx
   // 両方とも機能する
   import { ComponentName } from "@/components/atoms/ComponentName";
   import ComponentName from "@/components/atoms/ComponentName";
   ```

3. **コンポーネント移行の完了**
   - すべてのコンポーネント（atoms, molecules, organisms）が新しいディレクトリ構造に移行完了
   - 各コンポーネントは独自のディレクトリを持ち、実装ファイル、テストファイル、インデックスファイルを含む構造に統一
   - テストはすべて正常に動作し、コンポーネントの機能が正しく検証されている
   - インデックスファイルは名前付きエクスポートとデフォルトエクスポートの両方をサポートしている
   - 特にContactコンポーネントのテストでは、セクションの取得方法、テキスト検索、装飾要素のテスト方法を改善し、テストの安定性を向上させた

## リントチェックとコード品質の維持

1. **リントチェックの重要性**

   - コード変更後は必ず`yarn lint`を実行し、コード品質の問題を早期に発見する
   - 特に未使用のインポートや変数は、ビルドエラーの原因となるため積極的に削除する
   - テストファイルも含め、すべてのファイルに対してリントチェックを実行する
   - コミット前やプルリクエスト前にリントチェックを実行する習慣をつける

2. **未使用インポートの削除**

   - 未使用のインポートはパフォーマンスに悪影響を与え、バンドルサイズを増加させる
   - テストファイル内の未使用インポート（特にアイコンコンポーネント）も忘れずに削除する
   - コンポーネントのリファクタリング後は、不要になったインポートを確認して削除する
   - 特に`lucide-react`などのアイコンライブラリからのインポートは、使用しないものを残さない

3. **TypeScriptバージョンの互換性**
   - TypeScriptのバージョン（5.7.3）と`@typescript-eslint/typescript-estree`の互換性に注意する
   - 現在のサポート範囲は>=4.3.5 <5.4.0であるため、将来的にはTypeScriptのバージョンを調整するか、ESLintプラグインを更新することを検討する
   - パッケージの更新時には、TypeScriptとESLint関連パッケージの互換性を確認する

## デプロイ関連の記憶

1. **Vercelデプロイ前のチェックリスト**

   - 未使用の変数やインポートを削除
   - 型チェック、リントチェック、ビルドテストを必ず実行
   - 本番環境の設定でローカルビルドをテスト

2. **環境設定ファイルの互換性**
   - Next.jsの設定ファイルは`next.config.js`を使用
   - ESLintの設定は`.eslintrc.json`を使用
   - パッケージのバージョン互換性に注意（特にTypeScriptとESLint関連）

## 特定の実装に関する記憶

1. **ナビゲーションとヘッダー**

   - ヘッダーのGitHubアイコンとテーマトグルは、すべてのページで表示
   - ナビゲーションメニューはトップページ（`pathname === "/"`）でのみ表示
   - モバイルメニューボタンもトップページでのみ表示
   - スクロール検出機能によるヘッダーの背景色変更

2. **ホームページ構成**

   - 複数のセクション（About, Blogs, Skills, Contact）で構成
   - スクロールインジケーターによるユーザー誘導
   - 各セクションは視覚的に区別されつつも全体的な一貫性を保持

3. **コンタクトセクション**

   - Contactコンポーネント（organism）がセクションのレイアウトと装飾を担当
   - ContactFormコンポーネント（organism）がフォーム機能を提供
   - 明確な責任分担：Contactはレイアウトと視覚的要素、ContactFormはフォーム機能と状態管理
   - アニメーションによる視覚的な魅力の向上
   - Formspreeを使用したフォーム送信機能
   - 状態管理による送信プロセスの視覚的フィードバック
   - エラーハンドリングとユーザーフレンドリーなメッセージ表示
   - 環境変数による柔軟な設定

4. **アニメーション実装**
   - Framer Motionを使用して滑らかなアニメーションを実装
   - アクセシビリティに配慮し、`prefers-reduced-motion`に対応
   - スクロールアニメーションには`useInView`フックを使用
   - ホバーアニメーションには`whileHover`プロパティを使用
   - クリックアニメーションには`whileTap`プロパティを使用

## 開発中に遭遇した問題と解決策

1. **未使用インポートによるビルドエラー**

   - 問題: 未使用のインポートがビルド時にエラーを引き起こした
   - 解決策: デプロイ前に`yarn lint`と`yarn tsc --noEmit`を実行して未使用インポートを検出

2. **アイコンモックの不足によるテスト失敗**

   - 問題: 新しいアイコンを追加した際にテストが失敗
   - 解決策: `jest.setup.js`に新しいアイコンのモックを追加

3. **アトミックデザインの階層構造の逆転**

   - 問題: Contactコンポーネント（molecule）がContactFormコンポーネント（organism）を使用しており、階層構造が逆転
   - 解決策: Contactコンポーネントをmoleculesからorganismsに移動し、適切な階層構造を維持
   - 学び: コンポーネントの分類は責任範囲と複雑さに基づいて行い、依存関係の方向性を常に意識する

4. **コンポーネントディレクトリ構造変更後のインポートパスエラー**
   - 問題: コンポーネントをディレクトリ構造に移行した後、インポートパスが機能しなくなった
   - 解決策: index.tsファイルでコンポーネントの名前付きエクスポートとデフォルトエクスポートの両方を再エクスポート
   - 学び: コンポーネントのエクスポート方法とインポート方法の一貫性を確保することが重要

## 次のステップ

1. **コンポーネントドキュメントの充実**

   - 各コンポーネントの使用方法と設計意図を文書化
   - プロパティの型定義と使用例を明確に記述
   - 再利用可能なコンポーネントのカタログを作成

2. **Storybookの導入検討**

   - UIコンポーネントの視覚的なカタログとしてStorybookの導入を検討
   - 各コンポーネントの異なる状態とバリエーションを表示
   - インタラクティブなドキュメントとして活用

3. **テスト戦略の強化**

   - 単体テストだけでなく、統合テストとE2Eテストの導入を検討
   - テストカバレッジの目標を設定し、継続的に監視
   - テスト自動化のためのCI/CDパイプラインの整備

4. **パフォーマンス最適化**

   - Webバイタルの計測と改善
   - 画像とアセットの最適化
   - コード分割とレンダリング最適化の実施

5. **アクセシビリティの向上**
   - アクセシビリティ監査の実施
   - キーボードナビゲーションの改善
   - スクリーンリーダー対応の強化
   - カラーコントラストの最適化

## ディレクトリ構造の移行

1. **`lib/errors`ディレクトリの移行**

   - テストファイルを`src/__tests__/unit/lib/errors/`から`src/lib/errors/`に移動
   - 移行したテストファイル：
     - `ErrorBoundary.test.tsx`
     - `errorHandlers.test.ts`
     - `errorTypes.test.ts`
   - すべてのテストが正常に実行されることを確認
   - 元のテストファイルを削除
   - 移行後の構造：
     ```
     src/lib/errors/
       ├── ErrorBoundary.tsx
       ├── ErrorBoundary.test.tsx
       ├── errorHandlers.ts
       ├── errorHandlers.test.ts
       ├── errorTypes.ts
       ├── errorTypes.test.ts
       └── index.ts
     ```

2. **`hooks`ディレクトリの移行**

   - `useTheme`フックを新しいディレクトリ構造に移行
     - `src/hooks/useTheme.tsx`を`src/hooks/useTheme/useTheme.tsx`に移動
     - `index.ts`ファイルを作成して適切なエクスポートを設定
     - デフォルトエクスポートを追加
   - `useAnimationInView`フックを新しいディレクトリ構造に移行
     - `src/hooks/useAnimationInView.ts`を`src/hooks/useAnimationInView/useAnimationInView.ts`に移動
     - `index.ts`ファイルを作成して適切なエクスポートを設定
     - デフォルトエクスポートを追加
     - コードの改善（コメントの明確化、関数スタイルの統一）
   - 移行後の構造：

     ```
     src/hooks/useTheme/
       ├── useTheme.tsx
       ├── useTheme.test.tsx
       └── index.ts

     src/hooks/useAnimationInView/
       ├── useAnimationInView.ts
       ├── useAnimationInView.test.ts
       └── index.ts
     ```

3. **移行作業の手順**

   - 新しいディレクトリ構造を作成（`mkdir -p`コマンド）
   - ファイルを新しい場所にコピー（`cp`コマンド）
   - テストファイルも移動
   - `index.ts`ファイルを作成して適切なエクスポートを設定
   - デフォルトエクスポートを追加
   - テストを実行して動作確認
   - 元のファイルを削除
   - リントチェックとビルドテストを実行

4. **移行時の注意点**

   - インポートパスの更新が必要な場合がある
   - テストファイルのインポートパスも更新する
   - 移行後は必ずテストを実行して動作確認する
   - リントチェックで未使用のインポートを検出・削除する
   - ビルドテストで問題がないことを確認する

5. **移行の利点**
   - 関連するファイルが一箇所に集約され、コンポーネントの管理が容易に
   - インデックスファイルによるインポートパスの簡素化
   - 内部実装の詳細を隠蔽しつつ、使いやすいAPIを提供
   - コンポーネントの移動や名前変更が容易になり、リファクタリングのコストが低減
   - テストファイルの配置が明確になり、テスト実行の信頼性が向上
