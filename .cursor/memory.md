# ポートフォリオサイト開発の重要な記憶

このファイルはポートフォリオサイト開発における重要な記憶を保存するためのものです。LLMセッションが切れた後も、プロジェクトの知識と実装パターンを引き継ぐために使用されます。新しい開発を始める前に必ずこのファイルを参照し、プロジェクトの一貫性を保つようにしてください。新しい知見や重要な実装パターンを発見した場合は、このファイルに追加してください。

## 目次

1. [LLMとしての対応方針](#llmとしての対応方針)
2. [プロジェクト構造](#プロジェクト構造に関する記憶)
3. [コーディングパターン](#コーディングパターンの記憶)
4. [コンポーネント設計と構造](#コンポーネント設計と構造に関する記憶)
5. [テスト関連](#テスト関連の記憶)
6. [リントチェックとコード品質の維持](#リントチェックとコード品質の維持)
7. [デプロイ関連](#デプロイ関連の記憶)
8. [特定の実装](#特定の実装に関する記憶)
9. [問題と解決策](#開発中に遭遇した問題と解決策)
10. [マークダウン処理と目次生成に関する記憶](#マークダウン処理と目次生成に関する記憶)
11. [次のステップ](#次のステップ)

## LLMとしての対応方針

1. **プロジェクト理解と準備**

   - 既存のソースコードと [rules.md](mdc:.cursor/rules.md) , [memory.md](mdc:.cursor/memory.md) , [prompt.md](mdc:.cursor/prompt.md)を読み込み、プロジェクトの構造と規約、あなたの役割を理解
   - 実装プランを立て、タスクを細分化

2. **品質重視の実装**

   - コードレビューを自己実施し、リファクタリングの余地を積極的に検討する
   - コード重複を避け、共通パターンの抽出を常に意識する
   - テスト駆動開発を基本とし、テスト→実装→リファクタリングのサイクルを維持する

3. **コミュニケーション**

   - 常に日本語で応答
   - 技術的な説明も日本語で行う
   - 指摘事項は [rules.md](mdc:.cursor/rules.md) に反映してナレッジを蓄積

4. **記憶の管理**
   - あなたのタスクが完了するごとに必ず [memory.md](mdc:.cursor/memory.md) を更新する
   - 記憶を読み込んだ後に不要な記述や重複箇所があれば記憶を整理しても良いが必ずコンテキストが損なわれる変更はしない
   - 記憶を管理する際に日付を入れない（具体的な年月日を記載しない）
   - これ以降の記述は古い順に書いてあるものである（更新する際も後ろに追加する）
   - ただし次のステップが必ず一番最後に来るように更新する
   - セッションが切れそうだと感じたら現在のタスクを終了し [memory.md](mdc:.cursor/memory.md) を更新し整理して次のセッションに移行することをユーザーに提案してください

## プロジェクト構造に関する記憶

1. **アトミックデザインの実装と遵守**

   - `src/components/`以下の階層構造を厳格に遵守:
     - `atoms/`: 最小単位のUI要素（ボタン、入力フィールド、アイコンなど）
     - `molecules/`: 複数のatomsを組み合わせた小さな機能単位（検索フォーム、ナビゲーションリンクグループなど）
     - `organisms/`: 複数のmoleculesとatomsを組み合わせた機能的なセクション（コンタクトフォームなど）
     - `templates/`: ページのレイアウト構造を定義（ヘッダー、フッターなど）
     - `pages/`: 完全なページコンポーネント
   - 各コンポーネントは以下のディレクトリ構造を持つ:
     ```
     ComponentName/
     ├── ComponentName.tsx    # コンポーネント実装
     ├── ComponentName.test.tsx    # テスト
     └── index.ts             # エクスポート定義
     ```
   - アトミックデザインの階層構造を厳守し、上位のコンポーネントが下位のコンポーネントを使用する形を維持する
   - 具体的には、organisms → molecules → atoms の依存方向を守り、逆方向の依存（molecules → organisms）は避ける
   - 新規コンポーネントの作成時は、必ずこの構造に従うこと

2. **App Routerの活用**

   - `src/app/`以下にNext.jsのApp Routerパターンを採用
   - 各ページは`page.tsx`として実装し、共通レイアウトは`layout.tsx`で管理
   - エラー処理は`error.tsx`、ローディング状態は`loading.tsx`で統一的に実装

3. **型定義の集中管理**
   - `src/types/`ディレクトリで型定義を集中管理
   - コンポーネント間で共有される型は共通モジュールとして定義
   - 型安全性を確保するため、`any`型の使用を避け、明示的な型定義を徹底

## コーディングパターンの記憶

1. **条件付きレンダリングのパターン**

   ```tsx
   {
     isTopPage ? <NavigationMenu /> : <BackButton />;
   }
   ```

   - 条件によって表示/非表示を切り替える場合は、上記のパターンを使用
   - 特にナビゲーションメニューはトップページでのみ表示するルールを採用

2. **スタイリングの一貫性**

   ```tsx
   <div className={cn(
     "bg-gray-900/80 p-4 rounded-lg",
     "hover:bg-gray-800/90 transition-colors",
     className
   )}>
   ```

   - Tailwindのユーティリティクラスを`cn()`関数でグループ化
   - 背景色は暗めの色調、アクセント色は青系統を基本とする
   - コンポーネント間で視覚的な一貫性を保つよう注意

3. **エラーハンドリングパターン**

   ```tsx
   try {
     // 処理
   } catch (error) {
     console.error("エラーが発生しました:", error);
     return <ErrorComponent message="エラーが発生しました" />;
   }
   ```

   - エラー発生時は適切なエラーメッセージを表示
   - ユーザーフレンドリーなエラー表示を心がける

4. **データフェッチングパターン**
   ```tsx
   // サーバーコンポーネントでのデータフェッチ
   const data = await fetch("/api/data", { next: { revalidate: 3600 } }).then(
     (res) => res.json()
   );
   ```
   - 可能な限りサーバーコンポーネントでデータフェッチングを実施
   - 適切なキャッシュ戦略を設定

## コンポーネント設計と構造に関する記憶

1. **コンポーネントの標準ディレクトリ構造**

   - 各コンポーネントは以下の標準ディレクトリ構造を厳格に遵守すること:

   ```
   src/components/カテゴリ/
     └── ComponentName/
         ├── ComponentName.tsx    # コンポーネント実装
         ├── ComponentName.test.tsx    # テスト
         └── index.ts             # エクスポート定義
   ```

   - この構造により、関連ファイルが一箇所に集約され、コンポーネントの管理が容易になる
   - インデックスファイルを使用することで、インポートパスをシンプルに保ちながら内部実装の詳細を隠蔽できる
   - 新規コンポーネントの作成時は、必ずこの構造に従うこと

2. **コンポーネントのエクスポートとインポートの標準パターン**

   - コンポーネントファイル内では名前付きエクスポートとデフォルトエクスポートの両方を提供

   ```tsx
   export const ComponentName = () => {
     /* ... */
   };
   export default ComponentName;
   ```

   - index.tsファイルでは両方のエクスポート方法をサポート

   ```tsx
   export { default, ComponentName } from "./ComponentName";
   ```

   - これにより、利用側での柔軟なインポート方法を実現

   ```tsx
   // 両方とも機能する
   import { ComponentName } from "@/components/atoms/ComponentName";
   import ComponentName from "@/components/atoms/ComponentName";
   ```

3. **コンポーネント実装の基本ルール**

   - 新規コンポーネント作成時の手順：

     1. 適切なカテゴリディレクトリの選択（atoms, molecules, organisms, templates, pages）
     2. 標準ディレクトリ構造の作成
     3. 実装ファイル、テストファイル、インデックスファイルの作成
     4. テストの実装と実行
     5. リントチェックの実行（`yarn lint`）
     6. 最終テストとビルド検証の実行

   - 実装時の注意点：
     - インポートパスは`@/components/カテゴリ/ComponentName`の形式を使用
     - 型定義は明示的に行い、`any`型の使用を避ける
     - 未使用インポートは削除
     - コンポーネント間の依存関係はアトミックデザインの階層構造に従う

## テスト関連の記憶

1. **テストのモック実装と管理**

   - コンポーネントテストにおけるモック戦略:
     - 外部ライブラリ（アイコン、UIコンポーネント、フレームワーク機能）は一元的にモック
     - `jest.setup.js`でモックの基本設定を集中管理
     - 複雑なコンポーネントは階層構造を保持しつつ簡略化したモックを作成
   - 共通モックパターン:

     - アイコンコンポーネント: `data-testid`属性を持つ単純なspan要素
     - Framer Motionコンポーネント: 対応するHTML要素の単純版
     - 共通UIコンポーネント: 基本スタイルと`data-testid`を持つ要素
     - Next.jsフック: 適切な返り値を持つモック関数

   - モック管理の注意点:
     - 新しいライブラリやコンポーネントを追加した場合は必要なモックも追加
     - テスト失敗の多くはモックの不足に起因するため、モック設定を優先的に確認
     - モックの実装は実際のコンポーネント動作に近い挙動を再現

2. **テストの実行と安定性の確保**

   - テスト実行の基本ルール:
     - コンポーネント変更後は対応するテストを必ず実行
     - 構造変更後は全テストを実行して影響範囲を確認
     - ビルド前の全テスト実行による品質保証
   - テスト安定性向上の手法:

     - 要素取得は`data-testid`属性を優先使用
     - 非同期処理テストでは`waitFor`や`findBy*`クエリを使用
     - 複雑なテキスト検証は正規表現による部分一致を活用
     - セレクタは安定性の高い方法（id > role > class）を優先

   - テスト修正の優先順位:
     1. コンポーネントの意図と実装が正しい場合はテストを修正
     2. テストの期待値が正しい場合はコンポーネントを修正
     3. 両方に問題がある場合は設計から見直し

3. **コンポーネント移動に伴うテスト対応**

   - テストファイルの移動と更新の基本手順:
     1. テストファイルのディレクトリ移動
     2. インポートパスの更新
     3. `yarn test <テストファイル名>`による動作確認
     4. 失敗時はモック、アサーション、セレクタの見直し
   - 移動後の検証方法:
     - 個別テストの成功確認
     - コンポーネント間の相互作用を確認するための統合テスト
     - 全テスト実行によるシステム全体への影響確認

## リントチェックとコード品質の維持

1. **リントチェックの重要性と実行タイミング**

   - コード品質保証のためのリントチェック実行ポイント:
     - コンポーネント実装・修正後
     - コンポーネント移行作業の完了時
     - テスト実装・修正後
     - プルリクエスト作成前
     - ビルド実行前
   - リントチェックの基本コマンドと対象:
     ```bash
     yarn lint  # すべてのソースコードとテストファイルをチェック
     ```
   - リントチェックが特に重要な状況:
     - TypeScript型定義の問題検出
     - 未使用インポートや変数の発見
     - コードフォーマットの統一
     - 潜在的なバグの検出

2. **リントチェックを忘れやすい状況と対策**

   - リントチェックが見落とされやすい状況:
     - コンポーネント移行作業時（テスト実行に注力するあまりリントチェックを忘れる）
     - 小規模の修正時（影響が少ないと誤認する）
     - 急ぎのタスク対応時（品質チェックを後回しにする）
     - テストファイル修正時（本番コードほど重視しない傾向）
   - 効果的な対策:
     - コンポーネント移行チェックリストに「リントチェック」を明示的に追加
     - CIパイプラインでのリントチェック自動化
     - エディタ設定でのファイル保存時自動リント実行
     - テスト実行後に自動的にリントチェックを行うスクリプトの導入
   - `Footer.test.tsx`の事例にみる教訓:
     - テストファイルでも`any`型の使用は避け、具体的な型定義に置き換える
     - 例: `any`型の代わりに `{ children: React.ReactNode; [key: string]: unknown }` を使用
     - テストが成功していても型安全性が確保されていない可能性を認識

3. **コード品質向上のためのプラクティス**

   - 未使用インポートの削除:
     - 未使用インポートはバンドルサイズとパフォーマンスに悪影響
     - 定期的なリントチェックで検出と削除を習慣化
     - リファクタリング後は特に注意して確認
   - TypeScript互換性の管理:

     - 現環境ではTypeScript 5.7.3と@typescript-eslint/typescript-estreeの互換性に注意
     - サポート範囲は>=4.3.5 <5.4.0で、将来的な調整が必要
     - パッケージ更新時は互換性の確認を優先

   - 型安全性の確保:
     - `any`型の使用を避け、具体的な型定義を推奨
     - 特に外部ライブラリとの連携部分は明示的な型定義を提供
     - インターフェースと型エイリアスを適切に使い分け

## デプロイ関連の記憶

1. **Vercelデプロイ前のチェックリスト**

   - 品質確認コマンド:

     ```bash
     # 型チェック
     yarn tsc --noEmit

     # リントチェック
     yarn lint

     # テスト実行
     yarn test

     # ビルドテスト
     yarn build
     ```

   - チェックポイント:
     - 未使用の変数やインポートの削除
     - 型エラーの解消
     - テストの全件成功
     - ビルドの正常完了

2. **環境設定ファイルの管理**

   - 使用する設定ファイル形式:
     - Next.js設定: `next.config.js`
     - ESLint設定: `.eslintrc.json`
     - Jest設定: `jest.config.js`
   - 設定ファイル更新時の注意点:
     - パッケージのバージョン互換性確認
     - 環境変数の設定検証
     - ローカルとCI環境での一貫性確保

## 特定の実装に関する記憶

1. **ナビゲーションとヘッダー**

   - ヘッダーのGitHubアイコンとテーマトグルは、すべてのページで表示
   - ナビゲーションメニューはトップページ（`pathname === "/"`）でのみ表示
   - モバイルメニューボタンもトップページでのみ表示
   - スクロール検出機能によるヘッダーの背景色変更

2. **ホームページ構成**

   - 複数のセクション（About, Blogs, Skills, Contact）で構成
   - スクロールインジケーターによるユーザー誘導
   - 各セクションは視覚的に区別されつつも全体的な一貫性を保持

3. **コンタクトセクション**

   - Contactコンポーネント（organism）がセクションのレイアウトと装飾を担当
   - ContactFormコンポーネント（organism）がフォーム機能を提供
   - 明確な責任分担：Contactはレイアウトと視覚的要素、ContactFormはフォーム機能と状態管理
   - アニメーションによる視覚的な魅力の向上
   - Formspreeを使用したフォーム送信機能
   - 状態管理による送信プロセスの視覚的フィードバック
   - エラーハンドリングとユーザーフレンドリーなメッセージ表示
   - 環境変数による柔軟な設定

4. **アニメーション実装**
   - Framer Motionを使用して滑らかなアニメーションを実装
   - アクセシビリティに配慮し、`prefers-reduced-motion`に対応
   - スクロールアニメーションには`useInView`フックを使用
   - ホバーアニメーションには`whileHover`プロパティを使用
   - クリックアニメーションには`whileTap`プロパティを使用

## 開発中に遭遇した問題と解決策

1. **未使用インポートによるビルドエラー**

   - 問題: 未使用のインポートがビルド時にエラーを引き起こした
   - 解決策: デプロイ前に`yarn lint`と`yarn tsc --noEmit`を実行して未使用インポートを検出

2. **アイコンモックの不足によるテスト失敗**

   - 問題: 新しいアイコンを追加した際にテストが失敗
   - 解決策: `jest.setup.js`に新しいアイコンのモックを追加

3. **アトミックデザインの階層構造の逆転**

   - 問題: Contactコンポーネント（molecule）がContactFormコンポーネント（organism）を使用しており、階層構造が逆転
   - 解決策: Contactコンポーネントをmoleculesからorganismsに移動し、適切な階層構造を維持
   - 学び: コンポーネントの分類は責任範囲と複雑さに基づいて行い、依存関係の方向性を常に意識する

4. **コンポーネントディレクトリ構造変更後のインポートパスエラー**
   - 問題: コンポーネントをディレクトリ構造に移行した後、インポートパスが機能しなくなった
   - 解決策: index.tsファイルでコンポーネントの名前付きエクスポートとデフォルトエクスポートの両方を再エクスポート
   - 学び: コンポーネントのエクスポート方法とインポート方法の一貫性を確保することが重要

## マークダウン処理と目次生成に関する記憶

1. **日本語を含むマークダウン見出しのID生成**

   - 日本語を含む見出しからID生成する際の問題:
     - 英数字とハイフン以外をすべて削除する正規表現 `/[^\w\-]+/g` は日本語文字をすべて削除してしまう
     - これにより空のIDが生成され、目次の機能が壊れてしまう
   - 正しいID生成の実装パターン:

   ```typescript
   // マークダウンからHTMLに変換する際のID生成
   const id = text
     .toLowerCase()
     .trim()
     .replace(/[\s\t\n]+/g, "-") // 空白文字をハイフンに置換
     .replace(/[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g, "") // 特殊記号を削除
     .replace(/-+/g, "-") // 連続するハイフンを単一のハイフンに
     .replace(/^-|-$/g, ""); // 先頭と末尾のハイフンを削除

   // ID生成が空文字列になる場合のフォールバック
   const finalId =
     id ||
     `heading-${level}-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
   ```

   - このパターンは以下の特徴を持つ:
     - 日本語の文字を保持したまま特殊記号のみを削除
     - 空白文字のみをハイフンに変換
     - 連続するハイフンを単一のハイフンに正規化
     - 先頭と末尾のハイフンを削除してクリーンなIDを生成
     - 万が一空文字列になった場合のフォールバックを用意

2. **サーバーサイドおよびクライアントサイドの一貫したID生成**

   - マークダウンからHTMLへの変換（サーバーサイド）とTableOfContents（クライアントサイド）の両方で同じID生成ロジックを使用することが重要
   - この一貫性により以下の問題を防止:
     - 目次のリンククリック時にスクロールが機能しない
     - 自動スクロール追従が正しく動作しない
     - 目次項目と実際の見出しの不一致

3. **目次コンポーネントの実装パターン**

   - IntersectionObserverの設定:

   ```typescript
   const observerOptions = {
     rootMargin: "-80px 0px -70% 0px",
     threshold: [0.1, 0.5, 0.9],
   };
   ```

   - このパターンは以下の特徴を持つ:

     - 上部マージンは固定ヘッダーに対応するため負の値を指定
     - 下部マージンは大きな負の値で、画面上部に来た時点で活性化されるように設定
     - 複数の閾値を設定することで、より正確な検出が可能

   - アクティブ見出しのスタイル:

   ```tsx
   <a
     href={`#${heading.id}`}
     className={cn(
       "block py-1.5 border-l-2 pl-3 hover:text-primary transition-colors",
       activeId === heading.id
         ? "border-primary text-primary font-medium bg-primary/5"
         : "border-transparent text-muted-foreground"
     )}
   >
   ```

   - このパターンは以下の特徴を持つ:
     - 左ボーダーによる視覚的な強調
     - アクティブ時の背景色変更による視認性向上
     - テキスト色とフォントウェイトの変更による強調
     - hovr状態との視覚的な区別

4. **マークダウン処理のデバッグと保守**

   - 開発時のデバッグを容易にするパターン:

   ```typescript
   // 開発環境でのみデバッグ出力を有効化
   const DEBUG = process.env.NODE_ENV === "development";

   // デバッグログの出力
   if (DEBUG) {
     console.log("マークダウン内の見出し行:", headingLines);
     console.log("HTML内の見出しタグ:", headingTags);
     console.log("生成されたID:", idGeneratedHeadings);
   }
   ```

   - このパターンは以下の特徴を持つ:
     - 開発環境でのみログが出力され、本番環境ではログが抑制される
     - 必要な情報だけを選別して出力し、コンソールの肥大化を防ぐ
     - 異なる処理段階での出力を比較分析できるように情報を整理
     - 将来のデバッグのために重要な箇所にログポイントを残す

## 次のステップ

1. **コンポーネントドキュメントの体系化**

   - 各コンポーネントのAPI仕様と利用例の文書化
   - 型定義とプロパティの詳細説明
   - コンポーネント間の関係性と依存関係の可視化

2. **テスト戦略の強化**

   - テストカバレッジの向上と監視の仕組み導入
   - 単体テストの拡充と統合テストの追加
   - テスト自動化の拡充

3. **パフォーマンス最適化**

   - Webバイタルの計測と最適化
   - 画像・アセットの最適化
   - レンダリングパフォーマンスの向上

4. **アクセシビリティの向上**

   - アクセシビリティ監査の実施
   - キーボード操作性の改善
   - スクリーンリーダー対応の強化

5. **ブログコンテンツの充実**

   - 新しい記事の作成と既存記事の更新
   - 関連するキーワードやトピックに基づく関連記事の紹介
   - コミュニティとのやりとりの促進

6. **SEO対策の強化**

   - 検索エンジン最適化（SEO）の実施
   - キーワードの選択と埋め込み
   - サイトの構造とコンテンツの整理

7. **パフォーマンス最適化の継続**

   - 既存の最適化手法の継続と改善
   - 新しいツールやライブラリの導入
   - ユーザーのフィードバックに基づく継続的な改善

8. **UIデザインの微調整と改善**

   - 既存のデザインの見直しと改善
   - 新しいデザイン要素の導入
   - ユーザーのフィードバックに基づく継続的な改善
