# ポートフォリオサイト開発の重要な記憶

このファイルはポートフォリオサイト開発における重要な記憶を保存するためのものです。LLMセッションが切れた後も、プロジェクトの知識と実装パターンを引き継ぐために使用されます。新しい開発を始める前に必ずこのファイルを参照し、プロジェクトの一貫性を保つようにしてください。新しい知見や重要な実装パターンを発見した場合は、このファイルに追加することを検討してください。

## プロジェクト構造に関する記憶

1. **アトミックデザインの実装**

   - `src/components/`以下に`atoms/`, `molecules/`, `organisms/`, `templates/`, `pages/`の階層構造を採用
   - 各コンポーネントは責任範囲を明確にし、再利用性を高めるように設計
   - 特に`atoms`コンポーネントは最小単位のUI要素として、多くの場所で再利用されている
   - アトミックデザインの階層構造を厳守し、上位のコンポーネントが下位のコンポーネントを使用する形を維持する
   - 具体的には、organisms → molecules → atoms の依存方向を守り、逆方向の依存（molecules → organisms）は避ける
   - コンポーネントの責任範囲と複雑さに基づいて適切なカテゴリに分類する
     - atoms: ボタン、入力フィールド、アイコンなどの最小単位のUI要素
     - molecules: 複数のatomsを組み合わせた小さな機能単位（検索フォーム、ナビゲーションリンクグループなど）
     - organisms: 複数のmoleculesとatomsを組み合わせた機能的なセクション（ヘッダー、フッター、コンタクトフォームなど）
     - templates: ページのレイアウト構造を定義
     - pages: 完全なページコンポーネント

2. **App Routerの活用**

   - `src/app/`以下にNext.jsのApp Routerパターンを採用
   - 各ページは`page.tsx`として実装し、共通レイアウトは`layout.tsx`で管理
   - エラー処理は`error.tsx`、ローディング状態は`loading.tsx`で統一的に実装

3. **型定義の集中管理**
   - `src/types/`ディレクトリで型定義を集中管理
   - コンポーネント間で共有される型は共通モジュールとして定義
   - 型安全性を確保するため、`any`型の使用を避け、明示的な型定義を徹底

## コーディングパターンの記憶

1. **条件付きレンダリングのパターン**

   ```tsx
   {
     isTopPage && <NavigationMenu />;
   }
   {
     !isTopPage && <BackButton />;
   }
   ```

   - 条件によって表示/非表示を切り替える場合は、上記のパターンを使用
   - 特にナビゲーションメニューはトップページでのみ表示するルールを採用

2. **スタイリングの一貫性**

   ```tsx
   <div className={cn(
     "bg-gray-900/80 p-4 rounded-lg",
     "hover:bg-gray-800/90 transition-colors",
     className
   )}>
   ```

   - Tailwindのユーティリティクラスを`cn()`関数でグループ化
   - 背景色は暗めの色調、アクセント色は青系統を基本とする
   - コンポーネント間で視覚的な一貫性を保つよう注意

3. **エラーハンドリングパターン**

   ```tsx
   try {
     // 処理
   } catch (error) {
     console.error("エラーが発生しました:", error);
     return <ErrorComponent message="エラーが発生しました" />;
   }
   ```

   - エラー発生時は適切なエラーメッセージを表示
   - ユーザーフレンドリーなエラー表示を心がける

4. **データフェッチングパターン**
   ```tsx
   // サーバーコンポーネントでのデータフェッチ
   const data = await fetch("/api/data", { next: { revalidate: 3600 } }).then(
     (res) => res.json()
   );
   ```
   - 可能な限りサーバーコンポーネントでデータフェッチングを実施
   - 適切なキャッシュ戦略を設定

## テスト関連の記憶

1. **アイコンコンポーネントのモック**

   - `jest.setup.js`でLucide Reactなどのアイコンコンポーネントをモック化
   - 新しいアイコンを追加した場合は、必ずモックも追加する
   - テスト失敗の多くはアイコンモックの不足が原因だった

2. **テストの安定性向上**

   - レンダリングテストでは`data-testid`属性を活用
   - 非同期処理を含むテストでは`waitFor`や`findBy*`クエリを使用
   - スナップショットテストは変更が少ないコンポーネントに限定

3. **コンポーネント移動時のテスト対応**

   - コンポーネントを移動する際は、必ず対応するテストファイルも移動する
   - テストファイルのインポートパスも更新する
   - テストファイルの移動後、必ず`yarn test <テストファイル名>`を実行して動作確認する
   - テスト失敗時は、テキスト検索の問題（改行など）や要素の取得方法（role vs id）を確認する
   - コンポーネント移動後は全テスト（`yarn test`）とビルド（`yarn build`）を実行して問題がないことを確認する

4. **テスト実装の忘れやすいポイント**

   - 複雑なテキスト（改行を含む）は正規表現を使用して部分一致で検索する
   - セクション要素の取得は`getByRole("region")`よりも`getElementById()`の方が安定することがある
   - モックは個別のテストファイルではなく`jest.setup.js`で一元管理する
   - テストファイルの場所はコンポーネントの場所と一致させる（`src/__tests__/unit/components/organisms/`など）
   - コンポーネントの移動や名前変更を行った場合は、必ずテストも更新する

5. **テスト実行のルール**
   - コンポーネントの変更後は必ず対応するテストを実行する
   - 構造的な変更（ディレクトリ移動など）後は全テストを実行する
   - ビルド前に全テストを実行し、問題がないことを確認する
   - テスト失敗時は、コンポーネントとテストの両方を確認し、どちらを修正すべきか判断する
   - テストの修正はコンポーネントの意図を変えないように注意する

## デプロイ関連の記憶

1. **Vercelデプロイ前のチェックリスト**

   - 未使用の変数やインポートを削除
   - 型チェック、リントチェック、ビルドテストを必ず実行
   - 本番環境の設定でローカルビルドをテスト

2. **環境設定ファイルの互換性**
   - Next.jsの設定ファイルは`next.config.js`を使用
   - ESLintの設定は`.eslintrc.json`を使用
   - パッケージのバージョン互換性に注意（特にTypeScriptとESLint関連）

## パフォーマンス最適化の記憶

1. **画像最適化**

   - 画像には必ず`next/image`の`Image`コンポーネントを使用
   - 適切なサイズと品質設定で画像を最適化

2. **コンポーネントの最適化**
   - 不要な再レンダリングを防ぐため、適切な場所で`React.memo`を使用
   - 大きなリストには仮想化技術を適用

## スタイリングとデザインの記憶

1. **カラースキーム**

   - 背景色: 暗めの色調（`bg-gray-900/80`, `bg-gray-900`など）
   - アクセント色: 青系統（`text-blue-400`, `text-blue-300`など）
   - テキスト色: 明るめの色調（`text-white`, `text-gray-300`など）
   - 強調表示: グラデーション（`bg-gradient-to-r from-blue-400 to-purple-400`）

2. **レスポンシブデザイン**
   - モバイルファーストのアプローチを採用
   - 各ブレークポイントでの表示を確認
   - 特にナビゲーションメニューはモバイルとデスクトップで異なる表示方法を採用

## 特定の実装に関する記憶

1. **ナビゲーションとヘッダー**

   - ヘッダーのGitHubアイコンとテーマトグルは、すべてのページで表示
   - ナビゲーションメニューはトップページ（`pathname === "/"`）でのみ表示
   - モバイルメニューボタンもトップページでのみ表示

2. **アニメーション実装**
   - Framer Motionを使用して滑らかなアニメーションを実装
   - アクセシビリティに配慮し、`prefers-reduced-motion`に対応

## 最新のプロジェクト構造と実装ルールの記憶

1. **コンポーネント実装の共通ルール**

   - データ構造は論理的なカテゴリーで整理し、関連するデータをグループ化
   - 再利用可能なサブコンポーネントを作成し、一貫したデザインパターンを維持
   - 視覚的な進捗や状態表示には適切なUIコンポーネントを使用
   - 大量のデータや要素がある場合は、折りたたみ機能やページネーションを実装
   - アニメーションには`framer-motion`を使用し、スクロール時に要素が滑らかに表示されるよう実装

2. **フォーム実装の共通ルール**

   - フォームコンポーネントは独立したファイルとして実装し、責任範囲を明確化
   - 外部サービスとの連携には環境変数を使用し、設定を柔軟に変更できるよう実装
   - フォームの状態管理には適切なフックを使用し、初期状態、送信中、送信成功、エラー発生の状態を明確に定義
   - エラーハンドリングを適切に実装し、ユーザーフレンドリーなエラーメッセージを表示
   - 処理成功時には明確なフィードバックを提供し、次のアクションへの導線を用意

3. **ページ構成の共通ルール**

   - ページコンポーネントは論理的なセクションに分割し、各セクションの責任範囲を明確化
   - セクションの配置は情報の重要度と論理的な流れに基づいて決定
   - ユーザーの注意を引くための視覚的な要素を適切に配置
   - 各セクションは視覚的に区別しやすいデザインを採用しつつ、全体としての一貫性を保持
   - セクション間の移動はスムーズなスクロールを実装し、ユーザーエクスペリエンスを向上

4. **アニメーションとインタラクションの実装ルール**

   - アニメーションには`framer-motion`ライブラリを使用し、一貫したアニメーション体験を提供
   - アニメーションの定義は集中管理し、再利用可能な形で実装
   - スクロールアニメーションには`useInView`フックを使用し、要素が画面に入ったときにアニメーションをトリガー
   - ホバーアニメーションには`whileHover`プロパティを使用し、インタラクティブな要素に視覚的なフィードバックを提供
   - クリックアニメーションには`whileTap`プロパティを使用し、ボタンなどの要素に触覚的なフィードバックを提供

5. **スタイリングとデザインシステムの実装ルール**
   - スタイリングには`Tailwind CSS`を使用し、一貫したデザインシステムを構築
   - 共通のスタイル定義は集中管理し、再利用可能な形で実装
   - ユーティリティ関数`cn`を使用してクラス名を結合し、条件付きスタイリングを実現
   - カラースキームは一貫性を保ち、プロジェクト全体で統一されたカラーパレットを使用
   - ダークモードに対応し、すべてのコンポーネントが両方のテーマで適切に表示されるよう実装

## ポートフォリオサイトの主要コンポーネント構成

1. **ヘッダーコンポーネント**

   - GitHubアイコンとテーマトグルはすべてのページで表示
   - ナビゲーションメニューはトップページでのみ表示
   - モバイルメニューボタンもトップページでのみ表示
   - スクロール検出機能によるヘッダーの背景色変更

2. **フッターコンポーネント**

   - プロフィールセクション、ナビゲーションリンク、著作権表示を含む
   - ソーシャルリンクは現在コメントアウトされている

3. **ホームページ構成**

   - 複数のセクション（About, Blogs, Skills, Contact）で構成
   - スクロールインジケーターによるユーザー誘導
   - 各セクションは視覚的に区別されつつも全体的な一貫性を保持

4. **スキルコンポーネント**

   - スキルデータはカテゴリー別に整理
   - SkillCardコンポーネントによる一貫したデザイン
   - プログレスバーによるスキルレベルの視覚的表現
   - 折りたたみ機能による初期表示の最適化

5. **コンタクトセクション**
   - Contactコンポーネント（organism）がセクションのレイアウトと装飾を担当
   - ContactFormコンポーネント（organism）がフォーム機能を提供
   - 明確な責任分担：Contactはレイアウトと視覚的要素、ContactFormはフォーム機能と状態管理
   - アニメーションによる視覚的な魅力の向上
   - Formspreeを使用したフォーム送信機能
   - 状態管理による送信プロセスの視覚的フィードバック
   - エラーハンドリングとユーザーフレンドリーなメッセージ表示
   - 環境変数による柔軟な設定

## 追加ページの実装

1. **職歴ページ**

   - CareerTimelineコンポーネントによるキャリア情報の表示
   - 自己PR、資格、スキルセクションを含む
   - アニメーションによる視覚的な魅力の向上

2. **サイト紹介ページ**
   - ポートフォリオサイトで使用している技術の紹介
   - 各技術の説明とアイコン表示
   - 実装詳細の説明

## 今後の開発方針

1. **コンポーネントの抽象化と再利用性の向上**

   - 個別のコンポーネント実装から共通ルールに基づく実装へ移行
   - 新しいコンポーネント開発時には抽象化されたルールを適用

2. **デザインシステムの強化**

   - 視覚的一貫性の確保
   - アクセシビリティの向上
   - レスポンシブデザインの最適化

3. **パフォーマンス最適化**

   - アニメーションの最適化
   - 画像とアセットの最適化
   - コード分割とレンダリング最適化

4. **テスト強化**
   - 単体テスト、統合テスト、E2Eテストの拡充
   - テストカバレッジの向上
   - テスト環境の最適化

## 開発中に遭遇した問題と解決策

1. **未使用インポートによるビルドエラー**

   - 問題: 未使用のインポートがビルド時にエラーを引き起こした
   - 解決策: デプロイ前に`yarn lint`と`yarn tsc --noEmit`を実行して未使用インポートを検出

2. **アイコンモックの不足によるテスト失敗**

   - 問題: 新しいアイコンを追加した際にテストが失敗
   - 解決策: `jest.setup.js`に新しいアイコンのモックを追加

3. **環境依存のバグ**

   - 問題: 開発環境では動作するが本番環境では動作しない機能があった
   - 解決策: 本番環境の設定でローカルビルドをテストし、環境変数の違いを確認

4. **スタイルの一貫性の欠如**

   - 問題: コンポーネント間でスタイルの一貫性が取れていなかった
   - 解決策: 共通のスタイリングパターンを定義し、すべてのコンポーネントに適用

5. **アトミックデザインの階層構造の逆転**

   - 問題: Contactコンポーネント（molecule）がContactFormコンポーネント（organism）を使用しており、アトミックデザインの階層構造が逆転していた
   - 解決策: Contactコンポーネントをmoleculesからorganismsに移動し、適切な階層構造を維持
   - 学び: コンポーネントの分類は責任範囲と複雑さに基づいて行い、依存関係の方向性（organisms → molecules → atoms）を常に意識する
   - 実装手順:
     1. 新しい場所（organisms）にContactコンポーネントを作成
     2. Homeコンポーネントのインポートパスを更新
     3. テストファイルも新しい場所に移動
     4. 元のファイルを削除
     5. `yarn lint`、`yarn tsc --noEmit`、`yarn build`を実行して変更の品質を確認

6. **コンポーネント移動時のテスト忘れ**
   - 問題: コンポーネントを移動した際にテストの実行を忘れ、後になって問題が発覚した
   - 解決策: コンポーネント移動のチェックリストにテスト実行を明示的に追加
   - 学び: 構造的な変更（ディレクトリ移動、名前変更など）を行った場合は、必ずテストを実行して問題がないことを確認する
   - 実装手順:
     1. コンポーネントを移動する
     2. インポートパスを更新する
     3. テストファイルも移動する
     4. 特定のテスト（`yarn test <テストファイル名>`）を実行して問題がないことを確認する
     5. 全テスト（`yarn test`）を実行して他のテストへの影響がないことを確認する
     6. ビルド（`yarn build`）を実行して問題がないことを確認する

## LLMとしての対応方針

1. **コード実装前の準備**

   - 既存のソースコードを読み込み、プロジェクトの構造と規約を理解
   - 実装プランを立て、タスクを細分化

2. **コード品質の確保**

   - 実装後にコードの正確性を確認
   - リファクタリングの余地がある場合は改善を提案
   - コードの重複を避け、共通化を推進

3. **コミュニケーション**
   - 常に日本語で応答
   - 技術的な説明も日本語で行う
   - 指摘事項は.cursor/rulesに反映してナレッジを蓄積

## コンポーネント分類の改善に関する記憶

1. **アトミックデザインの階層と依存関係の方向性**

   - 正しい依存関係の方向: organisms → molecules → atoms
   - 避けるべき依存関係の方向: molecules → organisms（逆依存）
   - 2024年6月に`Contact`コンポーネントを`molecules`から`organisms`に移動
   - コンポーネントの責任範囲と複雑さに基づいて適切なカテゴリに分類することの重要性を確認

2. **コンポーネント移動時のチェックリスト**

   - インポートパスの更新
   - テストファイルの移動と更新
   - テストの実行による動作確認
   - ビルドの実行による問題がないことの確認
   - 依存関係の方向性の確認（上位カテゴリが下位カテゴリに依存することを確認）

3. **テスト実装の改善点**
   - `getByRole("region")`よりも`getElementById()`を使用する方が安定している場合がある
   - テキスト検索では、改行（`<br />`）で分割されたテキストに注意が必要
   - モックは`jest.setup.js`で一元管理し、テストファイル内で個別に定義しない

## テスト実行の重要性に関する記憶

1. **コード変更後のテスト実行の必要性**

   - あらゆるコード変更後には必ずテストを実行する
   - 特にコンポーネントの移動や名前変更などの構造的変更後は全テストを実行する
   - テスト実行を忘れると、後になって問題が発覚し、デバッグに時間がかかる

2. **テスト実行のタイミング**

   - コンポーネント実装直後
   - コンポーネント修正後
   - コンポーネント移動後
   - インポートパス変更後
   - 依存関係の変更後
   - ビルド前
   - デプロイ前

3. **テスト実行の手順**

   - 特定のテストファイルのみを実行: `yarn test <テストファイル名>`
   - 全テストを実行: `yarn test`
   - テスト失敗時は、エラーメッセージを注意深く読み、問題の原因を特定する
   - テスト修正後は再度テストを実行して問題が解決したことを確認する

4. **テスト実行の自動化**
   - CI/CDパイプラインでのテスト自動実行を検討する
   - プルリクエスト時に自動的にテストを実行するGitHubアクションを設定する
   - コミット前にテストを実行するGitフックを導入する
