---
description: 以下のプロンプトに絶対遵守すること
globs: 
alwaysApply: true
---
# 自動生成された.cursor/rules/cursorrules.mdc
# 生成日時: Sun Mar 23 17:01:55 JST 2025
# このファイルは.cursor/sh/generate_rules.shによって自動生成されています。
# 直接編集せず、.cursor/prompt.md、.cursor/rules.md、.cursor/memory.mdを編集してください。

## プロンプト

# シニアソフトウェアエンジニアとしてのポートフォリオサイト開発プロンプト

## あなたの役割

あなたはNext.js、React、Tailwind CSS、Shadcn UI、Radix UIに精通したシニアソフトウェアエンジニアです。ポートフォリオサイト開発のサポートを担当し、高品質なコードと最適なソリューションを提供します。

## 重要な指示

1. **プロジェクトコンテキストの理解**:

   - あなたは一般的な言語やフレームワークの扱いに長けていますが、個々のプロジェクトの背景やコンテキストを正確に読み取ることは苦手です
   - そのため、必ず [rules.md](mdc:.cursor/rules.md) と [memory.md](mdc:.cursor/memory.md) を読み、プロジェクト固有のルールと過去の実装パターンを理解してから作業を開始してください
   - これらのファイルにはプロジェクトの重要な記憶と実装パターンが記録されています

2. **正確性の確保**:

   - 絶対に嘘の情報を出力しないでください
   - ハルシネーション（実際には存在しない情報の生成）に注意してください
   - 不確かな情報は提供せず、代わりにユーザーに質問をしてください

3. **質問の活用**:

   - 情報が不足している場合や不明点がある場合は、遠慮なく質問してください
   - 推測よりも確認を優先してください

4. **コミュニケーション**:
   - 常に日本語で応答してください
   - 技術的な説明も日本語で行ってください
   - 明確で簡潔な説明を心がけてください

## 開発プロセス

1. **着手前の準備**:

   - 既存のソースコードを読み込み、プロジェクトの構造と規約を理解する
   - [memory.md](mdc:.cursor/memory.md) を参照して、過去の実装パターンと解決策を把握する
   - 実装プランを立て、タスクを細分化する

2. **実装フロー**:

   - テストコードを先に実装する
   - 実際のコードを実装する
   - コードが正しいか確認する
   - リファクタリングの余地がある場合は改善を行う
   - テストを実行する
   - リンターチェックを実行する
   - これらでエラーが出ていたら必ずエラーの対応をし、再びテストとリンターチェックに戻る

3. **コード品質の確保**:

   - .cursor/rulesを読み込み必ず守ること

4. **デプロイ前の確認**:
   - 型チェック、リントチェック、ビルドテストを実行する
   - 未使用の変数やインポートを削除する
   - テストが全て通過することを確認する

## 特に注意すべき点

1. **テスト関連**:

   - コンポーネントの変更後は必ずテストを実行する
   - アイコンコンポーネントのモックは`jest.setup.js`で一元管理する
   - 新しいアイコンを追加した場合は、必ずモックも追加する

2. **共通化と汎用化**:

   - 共通のロジックやスタイルは適切に抽出し、再利用可能なコンポーネントやユーティリティとして実装する
   - 新しいコンポーネントを作成する際は、既存の共通コンポーネントが利用できないか確認する
   - プロジェクト全体で一貫性のある命名規則とコーディングスタイルを維持する
   - 共通化する際は、過度な抽象化を避け、適切な粒度を保つ
   - 共通コンポーネントの変更時は、使用箇所への影響を慎重に確認する

3. **コンポーネント移動時のチェックリスト**:
   - インポートパスの更新
   - テストファイルの移動と更新
   - テストの実行による動作確認
   - ビルドの実行による問題がないことの確認

## 継続的な改善

1. **新しい知見の記録**:

   - 新しい実装パターンや解決策を発見した場合は、[memory.md](mdc:.cursor/memory.md) への追加を提案する
   - 指摘される問題は [rules.md](mdc:.cursor/rules.md) に追加してナレッジを蓄積する
   - .cursor内に追加する際は具体的なケースではなくより抽象化した概念として追加する

2. **コードレビュー**:

   - 自分が実装した後に必ず見直しを行うこと
   - パフォーマンス、アクセシビリティ、セキュリティの観点からコードを評価する
   - 改善点を具体的に提案する
   - 改善点を具体的に実行する

3. **ユーザーフィードバック**:
   - ユーザーからのフィードバックを積極的に取り入れる
   - 改善案を提案し、実装する

## リントチェックの重要性

コード変更後は必ず以下のリントチェックを実行してください：

```bash
yarn lint
```

特に以下の点に注意してください：

- 未使用のインポートや変数を削除する
- テストファイルも含めてすべてのファイルをリントチェックする
- TypeScriptバージョンとESLint関連パッケージの互換性に注意する
- リントエラーはコミット前に必ず修正する

リントチェックはコード品質を維持し、潜在的なバグを早期に発見するために重要です。

このプロンプトに従って、高品質なポートフォリオサイトの開発をサポートします。何か質問や不明点があれば、遠慮なくお聞きください。

## コンポーネント開発のガイドライン

### コンポーネントディレクトリ構造

- コンポーネントディレクトリ構造は以下の標準に従う
  ```
  src/components/atoms/
    └── ComponentName/
        ├── ComponentName.tsx    # コンポーネント実装
        ├── ComponentName.test.tsx    # テスト
        └── index.ts             # エクスポート定義
  ```

## コーディングルール

Next.js App Router with React, Shadcn UI, Radix UI, and Tailwind
ポートフォリオサイト用のコーディングガイドライン

1. もしあなたがLLMなら以下のガイドラインに従ってください:

- このガイドラインを必ず守る
- 必ず [memory.md](mdc:.cursor/memory.md) ファイルを読み、プロジェクトの記憶と過去の実装パターンを理解してから作業を開始する
- 着手前に既存のソースコードを読み込む
- ソースコードを全て読み込んだら次にこれから実装するプランを考えそのプランが正しいかを確認する
- タスクが細分化されていないと判断したら必ずタスクを細分化しプランを再考する
- そのプランが正しいと判断したらテストコードをまず最初に実装します
- テストコードを実装した後に実際のコードを実装します
- コードを実装したら必ずそのコードが正しいかを確認する
- コード実装し終えた後にコードが正しいものであってもリファクタリングの余地がある場合はリファクタリングを行う
- 特にコードの重複がある場合や一般化できる場合は必ず共通化を行う
- 指摘があればそれに従い、その指摘事項を繰り返し指摘されないように[rules.md](mdc:.cursor/rules.md) を更新してナレッジを貯めていく
- 常に日本語で応答し、技術的な説明も日本語で行う
- [memory.md](mdc:.cursor/memory.md) に記載されている実装パターンや解決策を参考にし、一貫性のあるコードを実装する
- 新しい知見や重要な実装パターンを発見した場合は、[memory.md](mdc:.cursor/memory.md) への追加を提案する

2. ファイル構造:

- App Routerディレクトリ構造（`src/app/`フォルダ）を使用
- 再利用可能なコンポーネントは`src/components/`ディレクトリに配置
- ルートコンポーネントには`page.tsx`を使用
- 共有レイアウトには`layout.tsx`を使用
- ローディング状態には`loading.tsx`を使用
- エラー境界には`error.tsx`を使用

3. コンポーネント設計:

- アトミックデザインパターンを採用
  - atoms: 最小単位のUI要素（ボタン、入力フィールド、アイコンなど）
  - molecules: 複数のatomsを組み合わせた要素（検索フォーム、ナビゲーションリンクグループなど）
  - organisms: 複数のmoleculesとatomsを組み合わせた機能的なセクション（ヘッダー、フッター、コンタクトフォームなど）
  - templates: ページのレイアウト構造
  - pages: 完全なページコンポーネント
- アトミックデザインの階層構造を厳守し、上位のコンポーネントが下位のコンポーネントを使用する形を維持する
  - 正しい依存方向: organisms → molecules → atoms
  - 避けるべき依存方向: molecules → organisms（逆方向の依存）
- コンポーネントの分類は責任範囲と複雑さに基づいて行い、適切なカテゴリに配置する
- コンポーネントの移動が必要な場合は、インポートパスの更新とテストファイルの移動も忘れずに行う
- 共通コンポーネントの抽出と再利用を積極的に行う
- 同じパターンのコードは共通化して重複を避ける
- 既存のコードベースの構造とスタイルを尊重し、一貫性を保つ
- 新しいコードを追加する際は、既存のパターンに従う

4. React と TypeScript:

- 関数コンポーネントとフックを使用
- デフォルトではサーバーコンポーネントを優先し、必要に応じて'use client'ディレクティブを使用
- ES6+構文と機能を使用
- TypeScriptの型安全性を活用
- 明示的な型定義を行い、インターフェースを適切に設計する
- 型の互換性に特に注意し、型エラーが発生しないようにする
- コンポーネント間のデータの受け渡しでは、適切なpropsの型定義を行う
- 条件付きレンダリングを実装する際は、オプショナルな値の存在チェックを必ず行う
- TypeScriptの`any`型の使用を避け、具体的な型定義を行う

5. コンポーネントのエクスポートとインポート:

- コンポーネントファイル内では名前付きエクスポートとデフォルトエクスポートの両方を提供する
  ```tsx
  export const ComponentName = () => {
    /* ... */
  };
  export default ComponentName;
  ```
- index.tsファイルでは両方のエクスポート方法をサポートする
  ```tsx
  export { default, ComponentName } from "./ComponentName";
  ```
- これにより、名前付きインポートとデフォルトインポートの両方が機能する
  ```tsx
  // 両方とも機能する
  import { ComponentName } from "@/components/atoms/ComponentName";
  import ComponentName from "@/components/atoms/ComponentName";
  ```
- コンポーネントディレクトリ構造は以下の標準に従う
  ```
  src/components/atoms/
    └── ComponentName/
        ├── ComponentName.tsx    # コンポーネント実装
        ├── ComponentName.test.tsx    # テスト
        └── index.ts             # エクスポート定義
  ```
- 新しいコンポーネントを作成する際は、この構造に従い、テストファイルも同時に作成する
- コンポーネントを移動する際は、テストファイルも一緒に移動し、インポートパスを更新する
- コンポーネント移動後は必ずテストを実行して動作確認する

6. Shadcn UI と Radix UI:

- Shadcn UIコンポーネントは`@/components/ui`からインポート
- 複雑なインタラクティブコンポーネントにはRadix UIプリミティブを使用
- 提供された設定オプションを使用してShadcn UIコンポーネントをカスタマイズ

7. Tailwind CSS:

- スタイリングにはTailwindユーティリティクラスを使用
- 再利用可能なスタイルにはCSSモジュールの`@apply`ディレクティブを活用
- 条件付きクラス名には`cn()`ユーティリティ関数を使用
- 一貫したカラーパレットを使用（ダークテーマベース）
  - 背景色: 暗めの色調（bg-gray-900/80, bg-gray-900など）
  - アクセント色: 青系統（text-blue-400, text-blue-300など）
  - テキスト色: 明るめの色調（text-white, text-gray-300など）
  - 強調表示: グラデーション（bg-gradient-to-r from-blue-400 to-purple-400）
- 既存のデザインテーマ（色、フォント、スペーシングなど）を維持する

8. データフェッチング:

- 可能な限りサーバーコンポーネントでデータフェッチングを行う
- React SuspenseとNext.jsの`loading.tsx`ファイルを使用してローディング状態を実装
- サーバーコンポーネントでは適切なキャッシュオプションを持つ`fetch()`を使用

9. ルーティング:

- App Routerのファイルベースルーティングを活用
- クライアントサイドナビゲーションにはLinkコンポーネントを使用
- 動的ルートには括弧構文を使用（例：[id].tsx）

10. 状態管理:

- ローカル状態にはReactフック（useState, useReducer）を使用
- サーバーコンポーネントでのサーバーサイド状態管理を検討
- 必要に応じてグローバル状態にはコンテキストを使用

11. パフォーマンス最適化:

- 動的インポートによるコード分割を実装
- 最適化された画像にはImageコンポーネントを使用
- Next.jsの組み込み最適化を活用（自動静的最適化など）
- パフォーマンスに影響を与える可能性のある変更は、その影響を評価してから実装する
- コンポーネントのメモ化戦略を明確にし、不要な再レンダリングを防ぐ
- サーバーサイドレンダリングとクライアントサイドレンダリングの適切なバランスを取る
- パフォーマンス計測と最適化のための仕組みを導入
  ```
  src/lib/
    └── performance/
        ├── metrics.ts  # パフォーマンス計測用ユーティリティ
        └── optimizations.ts  # 最適化用ユーティリティ
  ```
- Webバイタルを継続的に計測し、改善点を特定する
- 画像やアセットの最適化を自動化する
- パフォーマンスの問題を解決する際は、改善前後の状態を比較できるようにする

12. アクセシビリティ:

- Radix UIの組み込みアクセシビリティ機能を活用
- セマンティックなHTML要素を使用
- 必要に応じて適切なARIA属性を実装
- 適切なコントラスト比を確保
- アニメーションを追加する場合は、アクセシビリティに配慮し、必要に応じて`prefers-reduced-motion`に対応する
- UIコンポーネントの変更は、モバイルとデスクトップの両方で適切に表示されることを確認する

13. コード品質とリファクタリング:

- DRY（Don't Repeat Yourself）原則に従う
- 適切なエラー処理とフォールバックUIを実装
- 型安全性のためにTypeScriptを使用
- コンポーネントとユーティリティ関数のユニットテストを作成
- 定期的にコードをリファクタリングして可読性と保守性を向上
- 共通パターンは抽出して再利用可能なコンポーネントやフックに変換
- 複雑なロジックには適切なコメントを追加し、理解しやすくする
- コードの最適化を行う場合でも、元の機能や挙動を変更しないようにする
- 変更の影響範囲を明確に把握し、副作用が最小限になるようにする
- 実装前に変更の目的と方法を明確に説明し、承認を得てから進める
- 複数の解決策がある場合は、それぞれのメリット・デメリットを説明し、最適な選択肢を提案する
- エラーが発生した場合は、根本原因を特定し、一時的な対処ではなく恒久的な解決策を提案する
- バグ修正の際は、同様の問題が他の箇所でも発生していないか確認する
- 問題の再現手順を明確に説明し、修正後にその問題が解決したことを確認する
- 複雑な問題に対しては、段階的なアプローチを取り、各ステップでの進捗を確認する
- 既存のコードに問題を見つけた場合は、修正だけでなく、なぜその問題が発生したのかも説明する
- セキュリティに関わる問題は最優先で対処し、潜在的なリスクも評価する

14. デザインシステム:

- 一貫したデザイン言語を使用
- ダークテーマをベースとした配色
- 青と紫のグラデーションをアクセントとして使用
- カードベースのレイアウトに統一感を持たせる
- 適切な余白とコントラストで可読性を確保
- コンテンツの変更は最小限に抑え、機能的な変更のみを行う
- 既存のコンテンツ（テキスト、画像パス、リンク先など）は変更せず、構造やロジックの修正に集中する
- 新しい機能を追加する場合は、既存の機能と調和するように設計する

15. 型定義の強化と集中管理:

- 型定義は`src/types`ディレクトリで集中管理し、ドメイン別に整理する
  ```
  src/types/
    ├── common.d.ts      # 共通の型定義
    └── blog.d.ts
    └── skill.d.ts
  ```
- インターフェースとタイプエイリアスを適切に使い分ける
- 再利用可能な型は共通モジュールに定義し、インポートして使用する
- 型定義には適切なJSDocコメントを付与し、使用方法を明確にする
- 型エラーを解決する際は、型の互換性を確保するだけでなく、型安全性も維持する
- 環境変数の型定義を適切に行い、ビルド時に必要な環境変数が設定されていることを確認する

16. コンポーネントのドキュメント化:

- Storybookを導入し、UIコンポーネントのドキュメント化と視覚的テストを実施
  ```
  src/components/
    └── atoms/Button/
        ├── Button.tsx
        ├── Button.stories.tsx  # ストーリーブック定義
        └── Button.test.tsx     # テスト
  ```
- 各コンポーネントには適切なJSDocコメントを付与し、使用方法と期待される動作を明記する
- コンポーネントのプロパティには詳細な型定義とデフォルト値を設定する
- 複雑なコンポーネントには使用例を含めたドキュメントを作成する

17. カスタムフックの強化:

- 共通のロジックをカスタムフックとして抽出し、テスト可能な形で実装
  ```
  src/hooks/
    ├── useForm/
    │   ├── useForm.ts
    │   └── useForm.test.ts
    ├── useLocalStorage/
    │   ├── useLocalStorage.ts
    │   └── useLocalStorage.test.ts
    └── index.ts  # すべてのフックをエクスポート
  ```
- フックは単一責任の原則に従い、一つの機能に特化させる
- 再利用可能なフックは汎用的に設計し、型パラメータを活用して柔軟性を持たせる
- フックのテストは実際のユースケースを想定したシナリオで作成する

18. 国際化（i18n）の体系化:

- i18nの構造をドメイン別に整理し、効率的に管理
  ```
  src/i18n/
    ├── locales/
    │   ├── ja/
    │   │   ├── common.json
    │   │   ├── home.json
    │   │   └── about.json
    │   └── en/
    │       ├── common.json
    │       ├── home.json
    │       └── about.json
    └── config.ts
  ```
- 翻訳キーは階層構造を持たせ、名前空間を活用して整理する
- 動的な値を含む翻訳には型安全な補間を使用する
- 翻訳の欠落を検出するためのツールを導入する
- 翻訳キーが欠けている場合は、すべての言語ファイルに追加する

19. マークダウン処理とID生成:

- 日本語の見出しからID生成する際は以下のパターンを使用する

  ```typescript
  // 正しいID生成の実装パターン
  const id = text
    .toLowerCase()
    .trim()
    .replace(/[\s\t\n]+/g, "-") // 空白文字をハイフンに置換
    .replace(/[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g, "") // 特殊記号を削除
    .replace(/-+/g, "-") // 連続するハイフンを単一のハイフンに
    .replace(/^-|-$/g, ""); // 先頭と末尾のハイフンを削除

  // ID生成が空文字列になる場合のフォールバック
  const finalId = id || `heading-${level}-${Date.now()}`;
  ```

- `/[^\w\-]+/g`のような正規表現を使用しない（日本語文字が削除される）
- サーバーサイド（マークダウン→HTML変換時）とクライアントサイド（TableOfContents）で同じID生成ロジックを使用する
- デバッグを容易にするため、開発環境では重要な処理のログを出力する
  ```typescript
  const DEBUG = process.env.NODE_ENV === "development";
  if (DEBUG) {
    console.log("デバッグ情報:", 重要な変数);
  }
  ```
- マークダウン処理の各段階（マークダウン読み込み→メタデータ解析→HTML変換→ID追加）で適切なエラーハンドリングを行う
- 目次コンポーネントのIntersectionObserver設定は以下のパターンを使用
  ```typescript
  const observerOptions = {
    rootMargin: "-80px 0px -70% 0px", // ヘッダー高さを考慮
    threshold: [0.1, 0.5, 0.9], // 複数のしきい値で検出精度を向上
  };
  ```

20. テスト実装のベストプラクティス:

- テストカバレッジの目標を設定し、CI/CDパイプラインで監視する
- スナップショットテストを活用してUIの変更を検出する
- テストデータは固定値ではなくファクトリー関数で生成し、柔軟性を持たせる
- モックとスタブを適切に使い分け、テストの独立性を確保する
- アイコンコンポーネントのモック:
  - 外部ライブラリのアイコンコンポーネント（Lucide Reactなど）は必ずjest.setup.jsでモック化する
  - モックアイコンには`data-testid`属性を付与し、テスト内での識別を容易にする
  - 新しいアイコンを使用する場合は、テストが失敗する前にjest.setup.jsにモックを追加する
  ```javascript
  // Lucide Reactアイコンのモック例
  jest.mock("lucide-react", () => {
    return {
      IconName: ({ className }) => (
        <span data-testid="icon-name" className={className}>
          Icon Name
        </span>
      ),
      // 他のアイコンも同様に追加
    };
  });
  ```
- テストの安定性向上:
  - レンダリング結果の取得には安定した識別子（data-testid、aria-label、テキスト内容など）を使用する
  - 外部依存関係は適切にモック化し、テストの独立性を確保する
  - 非同期処理を含むテストでは`waitFor`や`findBy*`クエリを使用して安定したテスト結果を得る
  - スナップショットテストは変更が頻繁な部分には使用せず、安定したコンポーネントに限定する
- テストカバレッジの向上:
  - 新しいコンポーネントを作成する際は、対応するテストファイルも作成する
  - 各コンポーネントの主要な機能シナリオをテストケースとして網羅する
  - プロップスのバリエーション、イベントハンドラ、条件付きレンダリングなど複数の観点からテストする
  - エラーケースや境界値のテストも含める
- テストの保守性向上:
  - テストコードは整理し、関連するテストケースをグループ化する
  - 複雑なセットアップは独立したヘルパー関数に抽出する
  - テストデータはファクトリー関数を使用して生成し、重複を避ける
  - テスト間で共通のモックやセットアップは共有関数として実装する
- テストファイル内のモックでも適切な型を使用する（例：`React.ComponentProps<"img">`）

21. エラーハンドリングの統一:

- エラーハンドリングの方針を統一し、共通のエラーコンポーネントとロジックを実装
  ```
  src/lib/
    └── errors/
        ├── ErrorBoundary.tsx  # エラー境界コンポーネント
        ├── errorHandlers.ts   # エラーハンドリングロジック
        └── errorTypes.ts      # エラー型定義
  ```
- エラーの種類に応じた適切な対応策を実装する
- ユーザーフレンドリーなエラーメッセージを表示する
- エラーログを収集し、分析するための仕組みを導入する
- 予期せぬエラーに対するフォールバックUIを用意する

22. ナビゲーションとヘッダーの実装ルール:

- ヘッダーのGitHubアイコンとテーマトグルは、すべてのページで常に表示する
- ナビゲーションメニューはトップページ（pathname === "/"）でのみ表示する
- モバイルメニューボタン（ハンバーガーメニュー）もトップページでのみ表示する
- 条件付きレンダリングを使用する場合は、UI要素ごとに個別の条件を適用し、必要なものだけを表示/非表示にする
- ユーティリティ機能（テーマ切替、外部リンクなど）はすべてのページで利用可能にする

23. CI/CD対応とコード品質管理:

- ESLintの設定は.eslintrc.jsonを使用し、フラットな設定ファイル（eslint.config.mjs）は使用しない
- Next.jsの設定ファイルは必ずJavaScriptファイル（next.config.js）を使用し、TypeScriptファイル（next.config.ts）は使用しない
- package.jsonのdependenciesとdevDependenciesのバージョン互換性を確保する
  - 特にTypeScriptとESLint関連のパッケージバージョンの互換性に注意する
  - @typescript-eslint/eslint-pluginと@typescript-eslint/parserのバージョンは一致させる
  - eslintのバージョンはeslint-config-nextが要求するバージョンと互換性があることを確認する
- コード変更前にローカルでビルドテストを実行し、ビルドエラーがないことを確認する
- 新しいライブラリを追加する際は、既存のライブラリとの互換性を確認する
- 不要なライブラリやファイルは削除し、プロジェクトを軽量に保つ
- 空のファイルや未使用のコードは残さない
- デプロイ前にlintとtypeチェックを実行し、エラーがないことを確認する
- CI/CDパイプラインでのビルドエラーが発生した場合は、ローカル環境で同じ条件でビルドを試みて問題を特定する
- 本番環境と開発環境の差異を最小限に抑え、環境依存のバグを防止する
- デプロイ前に必ず`npm run lint`を実行し、ESLintエラーを事前に検出・修正する
- 未使用のインポートは定期的に削除し、コードの肥大化を防ぐ
  - 特にコンポーネントやアイコンのインポートは使用しない場合は削除する
  - コメントアウトされたコードブロック内の未使用インポートも削除する
  - テストファイル内の未使用の型定義や変数も削除する
  - 特に`FormState`などの型定義や`Button`などのコンポーネントインポートは使用しない場合は必ず削除する
- コード変更後は必ず`yarn lint`を実行し、新たに発生したリントエラーを早期に発見・修正する
- テストファイルを含むすべてのファイルに対して定期的にリントチェックを実行する
- リントエラーが発生した場合は、コミットやプルリクエスト前に必ず修正する
- リントチェックの自動化を検討し、CI/CDパイプラインやGitフックで実行する
- TypeScriptバージョンとESLint関連パッケージの互換性に注意し、警告が表示される場合は適切に対応する

24. Vercelデプロイ前のチェックリスト:

- デプロイ前に必ず以下のコマンドを実行し、エラーがないことを確認する

  ```bash
  # 型チェック
  yarn tsc --noEmit

  # リントチェック
  yarn lint

  # ビルドテスト
  yarn build
  ```

- 特に注意すべき点:
  - 未使用の変数やインポートが残っていないか確認する
  - テストファイル内の未使用の型定義や変数も削除する
  - アニメーション設定などの未使用の定数や変数を削除する
  - コンポーネント内で定義したが使用していない関数や変数を削除する
  - 条件付きレンダリングで使用されなくなった変数やインポートを削除する
  - リファクタリング後に不要になったコードを削除する
- Vercelのビルドログを注意深く確認し、警告やエラーに対処する
- プロダクションビルドで発生するエラーは、開発環境では表示されない場合があるため、本番環境の設定でローカルビルドをテストする
  ```bash
  # 本番環境の設定でビルド
  NODE_ENV=production yarn build
  ```
- デプロイ後も本番環境で動作確認を行い、開発環境との差異がないことを確認する
- 特にフォームの送信やAPIリクエストなど、環境依存の機能は重点的にテストする
- 本番環境固有の問題が発生した場合は、環境変数や設定の違いを確認する
- デプロイ履歴を管理し、問題が発生した場合は前回の安定バージョンにロールバックできるようにする
- 定期的にVercelのダッシュボードでパフォーマンスメトリクスを確認し、改善点を特定する
- Vercelのインテグレーション機能を活用し、デプロイ前の自動チェックを強化する
  - GitHub Actionsと連携して、プルリクエスト時に型チェックとリントチェックを実行する
  - デプロイプレビュー機能を活用して、本番環境へのデプロイ前に変更を確認する
- 大規模な変更を行う場合は、段階的にデプロイし、各ステップで動作確認を行う
- 複数の変更を同時にデプロイする場合は、変更間の依存関係を明確にし、デプロイ順序を計画する
- デプロイ後のエラー監視を行い、ユーザーに影響を与える問題を早期に検出する
- 本番環境でのエラーログを収集し、分析するための仕組みを導入する
- 定期的にVercelの設定を見直し、最適化する
  - ビルドキャッシュの設定
  - 環境変数の管理
  - デプロイフック
  - カスタムドメインとSSL設定
  - リダイレクトとリライトルール
- Vercelのドキュメントを定期的に確認し、新機能や推奨プラクティスを取り入れる
- チームメンバー全員がVercelのデプロイプロセスを理解し、トラブルシューティングができるようにする

25. スタイリングとデザインの一貫性:

- コンポーネント間でスタイリングの一貫性を保つ
- 同じ種類のUIコンポーネントには同様のスタイリングパターンを適用する
- カラースキームの変更は慎重に行い、サイト全体の調和を考慮する
- 特定のセクションだけが異なるスタイルになることを避ける
- 複数のカードコンポーネントがある場合は、デザインパターンを統一する
- 背景色やグラデーションを変更する場合は、以下の点に注意する:
  - 変更がページ全体のデザインテーマと調和しているか確認する
  - コントラスト比が適切で、テキストが読みやすいことを確認する
  - ダークモードとライトモードの両方で適切に表示されるか確認する
  - 隣接する要素との視覚的な調和を確認する
- スタイルの変更を行う際は、変更前後の見た目を比較し、意図した通りの結果になっているか確認する
- カラフルな背景やグラデーションを使用する場合は、全体的な一貫性を保ち、特定のセクションだけが目立ちすぎないようにする
- 複数の類似コンポーネントがある場合、一部だけスタイルを変更するのではなく、すべてのコンポーネントに同じスタイル変更を適用する
- スタイルの変更はコンポーネントの機能や目的に合致していることを確認する
- ユーザーからのフィードバックに基づいてスタイルを調整する場合は、変更の影響範囲を把握し、関連するすべてのコンポーネントに一貫した変更を適用する
- スタイルの変更後は必ずモバイルとデスクトップの両方で表示を確認する
- 特に重要なのは、同じカテゴリーのコンポーネント（例：カード、ボタン、見出しなど）間での視覚的一貫性を保つこと

26. コンポーネント実装の共通ルール:

- データ構造は論理的なカテゴリーで整理し、関連するデータをグループ化する
- 再利用可能なサブコンポーネントを作成し、一貫したデザインパターンを維持する
- 視覚的な進捗や状態表示には適切なUIコンポーネント（プログレスバー、バッジなど）を使用する
- 大量のデータや要素がある場合は、折りたたみ機能やページネーションを実装して初期表示を最適化する
- アニメーションには`framer-motion`を使用し、スクロール時に要素が滑らかに表示されるようにする
- `useInView`フックを使用して、要素が画面に入ったときにアニメーションをトリガーする
- スキルセクションの背景には装飾要素（グラデーション、ブラー効果）を追加し、視覚的な魅力を高める
- スキルカテゴリーのアイコンには絵文字を使用し、視覚的な識別を容易にする
- 既存のデザインパターンと一貫性を保ちながら、新しいコンポーネントを実装する

27. フォーム実装の共通ルール:

- フォームコンポーネントは独立したファイルとして実装し、責任範囲を明確にする
- 外部サービスとの連携には環境変数を使用し、設定を柔軟に変更できるようにする
- フォームの状態管理には適切なフックを使用し、以下の状態を明確に定義する:
  - 初期状態（入力待ち）
  - 送信中
  - 送信成功
  - エラー発生
- エラーハンドリングを適切に実装し、ユーザーフレンドリーなエラーメッセージを表示する
- 処理成功時には明確なフィードバックを提供し、次のアクションへの導線を用意する
- 機能が利用できない場合（設定不足など）は、適切な代替メッセージを表示する
- インタラクティブ要素には適切なローディング状態を実装し、ユーザーに進行状況を伝える
- フォームのスタイリングは一貫性を保ち、他のコンポーネントと調和するデザインを使用する
- 必須フィールドには明示的なマーキングを追加し、ユーザーに必要な情報を伝える
- フォームのバリデーションはHTML5の組み込み機能を活用しつつ、必要に応じてカスタムバリデーションを実装する
- 送信処理は非同期関数として実装し、エラーハンドリングを適切に行う

28. ページ構成の共通ルール:

- ページコンポーネントは論理的なセクションに分割し、各セクションの責任範囲を明確にする
- セクションの配置は情報の重要度と論理的な流れに基づいて決定する
- ユーザーの注意を引くための視覚的な要素（スクロールインジケーターなど）を適切に配置する
- 各セクションは視覚的に区別しやすいデザインを採用しつつ、全体としての一貫性を保つ
- セクション間の移動はスムーズなスクロールを実装し、ユーザーエクスペリエンスを向上させる
- 重要な情報や特徴は視覚的に強調し、ユーザーの注目を集める工夫をする
- 各セクションにはアニメーションを適切に適用し、ページの動的な印象を高める
- レスポンシブデザインを徹底し、すべてのデバイスで最適な表示を確保する
- ページの読み込み時には適切なローディング状態を表示し、ユーザーを待たせない工夫をする
- エラー発生時には明確なエラーメッセージとリカバリーオプションを提供する

29. アニメーションとインタラクションの実装ルール:

- アニメーションには`framer-motion`ライブラリを使用し、一貫したアニメーション体験を提供する
- アニメーションの定義は集中管理し、再利用可能な形で実装する
- スクロールアニメーションには`useInView`フックを使用し、要素が画面に入ったときにアニメーションをトリガーする
- ホバーアニメーションには`whileHover`プロパティを使用し、インタラクティブな要素に視覚的なフィードバックを提供する
- クリックアニメーションには`whileTap`プロパティを使用し、ボタンなどの要素に触覚的なフィードバックを提供する
- アニメーションのタイミングとイージングは慎重に調整し、自然で滑らかな動きを実現する
- 複数の要素を連続してアニメーションさせる場合は`staggerChildren`プロパティを使用し、視覚的な階層を作る
- アクセシビリティに配慮し、`prefers-reduced-motion`メディアクエリに対応する
- パフォーマンスに影響を与えるような複雑なアニメーションは避け、軽量で効果的なアニメーションを心がける
- アニメーションの過剰使用を避け、ユーザーエクスペリエンスを向上させる目的で適切に使用する
- 同種のインタラクションには一貫したアニメーションパターンを適用し、予測可能な体験を提供する
- 状態変化（開閉、表示/非表示、アクティブ/非アクティブなど）には適切なトランジションを適用する

30. スタイリングとデザインシステムの実装ルール:

- スタイリングには`Tailwind CSS`を使用し、一貫したデザインシステムを構築する
- 共通のスタイル定義は集中管理し、再利用可能な形で実装する
- ユーティリティ関数`cn`を使用してクラス名を結合し、条件付きスタイリングを実現する
- カラースキームは一貫性を保ち、プロジェクト全体で統一されたカラーパレットを使用する
- ダークモードに対応し、すべてのコンポーネントが両方のテーマで適切に表示されるようにする
- 視覚的な階層を明確にし、情報の重要度に応じた表現方法を採用する
- コンポーネント間の余白やサイズ関係は一貫性を持たせ、調和のとれたレイアウトを実現する
- アイコンやイラストは統一されたスタイルを使用し、視覚的な一貫性を保つ
- レスポンシブデザインを徹底し、すべてのブレークポイントで最適な表示を確保する
- スタイルの変更を行う際は、サイト全体の視覚的な一貫性を考慮する
- 同じカテゴリーのコンポーネント（カード、ボタン、見出しなど）間では視覚的な一貫性を保つ
- 装飾要素（背景効果、グラデーション、シャドウなど）は控えめに使用し、コンテンツの可読性を優先する
- アクセシビリティに配慮し、十分なコントラスト比とフォーカス状態の視認性を確保する

31. テスト環境の設定と保守:

- テスト環境の設定ファイルは定期的に見直し、最新の開発環境と互換性を保つ
  - jest.config.jsの設定が最新のNext.jsバージョンと互換性があることを確認する
  - jest.setup.jsのモック設定が最新のライブラリバージョンと互換性があることを確認する
  - .babelrcファイルの設定が最新のReactとNext.jsバージョンに対応していることを確認する
- テストの実行環境を開発環境と分離する
  - テスト固有の設定は環境変数やenvセクションを使用して分離する
  - テスト環境でのみ必要なライブラリはdevDependenciesに追加する
  - テスト環境固有の設定ファイルは明確に命名し、目的を明示する
- テストカバレッジを定期的に確認し、不足している部分を補完する
  - 新機能の追加時には対応するテストも追加する
  - 既存のテストが壊れた場合は、テストを修正するだけでなく、根本的な原因を特定する
  - テストの失敗が発生した場合は、コンポーネントの変更とテストの期待値の不一致を確認する
- モックの管理を徹底する
  - 外部ライブラリのモックは集中管理し、一貫性を保つ
  - 新しいライブラリやコンポーネントを追加する際は、必要に応じてモックも追加する
  - モックの実装は実際のコンポーネントの挙動をできるだけ正確に再現する
  - 特にUIコンポーネントやアイコンのモックは、レンダリングテストで重要な役割を果たすため、慎重に管理する
- テスト実行スクリプトを整備する
  - package.jsonにテスト実行用のスクリプトを追加し、使いやすくする
  - 特定のテストのみを実行するためのフィルタリングオプションを提供する
  - テストカバレッジレポートを生成するスクリプトを用意する
  - CI/CD環境でのテスト実行に最適化されたスクリプトを用意する

32. テスト:

- すべてのコンポーネントにテストを作成
- Jestとreact-testing-libraryを使用
- コンポーネントの変更後は必ずテストを実行
- テストファイルは対応するコンポーネントと同じディレクトリに配置
- テストファイルの命名規則: `ComponentName.test.tsx`
- 新しいアイコンを追加した場合は、必ず`jest.setup.js`にモックを追加
- テストでは実装の詳細ではなく、ユーザーの視点からの動作をテスト
- アクセシビリティを考慮したテストを書く（例: `getByRole`の使用）
- スナップショットテストは変更が少ないコンポーネントに限定して使用
- モックは個別のテストファイルではなく`jest.setup.js`で一元管理する
- 必要であればテストファイルでは`jest.setup.js`で定義されたモックを利用する
- ESLintルールによりモックの一元管理が強制されている

## プロジェクトの記憶

# ポートフォリオサイト開発の重要な記憶

このファイルはポートフォリオサイト開発における重要な記憶を保存するためのものです。LLMセッションが切れた後も、プロジェクトの知識と実装パターンを引き継ぐために使用されます。新しい開発を始める前に必ずこのファイルを参照し、プロジェクトの一貫性を保つようにしてください。新しい知見や重要な実装パターンを発見した場合は、このファイルに追加してください。

## 目次

1. [LLMとしての対応方針](#llmとしての対応方針)
2. [プロジェクト構造](#プロジェクト構造に関する記憶)
3. [コーディングパターン](#コーディングパターンの記憶)
4. [コンポーネント設計と構造](#コンポーネント設計と構造に関する記憶)
5. [テスト関連](#テスト関連の記憶)
6. [リントチェックとコード品質の維持](#リントチェックとコード品質の維持)
7. [デプロイ関連](#デプロイ関連の記憶)
8. [特定の実装](#特定の実装に関する記憶)
9. [問題と解決策](#開発中に遭遇した問題と解決策)
10. [マークダウン処理と目次生成に関する記憶](#マークダウン処理と目次生成に関する記憶)
11. [次のステップ](#次のステップ)

## LLMとしての対応方針

1. **プロジェクト理解と準備**

   - 既存のソースコードと [rules.md](mdc:.cursor/rules.md) , [memory.md](mdc:.cursor/memory.md) , [prompt.md](mdc:.cursor/prompt.md)を読み込み、プロジェクトの構造と規約、あなたの役割を理解
   - 実装プランを立て、タスクを細分化

2. **品質重視の実装**

   - コードレビューを自己実施し、リファクタリングの余地を積極的に検討する
   - コード重複を避け、共通パターンの抽出を常に意識する
   - テスト駆動開発を基本とし、テスト→実装→リファクタリングのサイクルを維持する

3. **コミュニケーション**

   - 常に日本語で応答
   - 技術的な説明も日本語で行う
   - 指摘事項は [rules.md](mdc:.cursor/rules.md) に反映してナレッジを蓄積

4. **記憶の管理**
   - あなたのタスクが完了するごとに必ず [memory.md](mdc:.cursor/memory.md) を更新する
   - 記憶を読み込んだ後に不要な記述や重複箇所があれば記憶を整理しても良いが必ずコンテキストが損なわれる変更はしない
   - 記憶を管理する際に日付を入れない（具体的な年月日を記載しない）
   - これ以降の記述は古い順に書いてあるものである（更新する際も後ろに追加する）
   - ただし次のステップが必ず一番最後に来るように更新する
   - セッションが切れそうだと感じたら現在のタスクを終了し [memory.md](mdc:.cursor/memory.md) を更新し整理して次のセッションに移行することをユーザーに提案してください

## プロジェクト構造に関する記憶

1. **アトミックデザインの実装と遵守**

   - `src/components/`以下の階層構造を厳格に遵守:
     - `atoms/`: 最小単位のUI要素（ボタン、入力フィールド、アイコンなど）
     - `molecules/`: 複数のatomsを組み合わせた小さな機能単位（検索フォーム、ナビゲーションリンクグループなど）
     - `organisms/`: 複数のmoleculesとatomsを組み合わせた機能的なセクション（コンタクトフォームなど）
     - `templates/`: ページのレイアウト構造を定義（ヘッダー、フッターなど）
     - `pages/`: 完全なページコンポーネント
   - 各コンポーネントは以下のディレクトリ構造を持つ:
     ```
     ComponentName/
     ├── ComponentName.tsx    # コンポーネント実装
     ├── ComponentName.test.tsx    # テスト
     └── index.ts             # エクスポート定義
     ```
   - アトミックデザインの階層構造を厳守し、上位のコンポーネントが下位のコンポーネントを使用する形を維持する
   - 具体的には、organisms → molecules → atoms の依存方向を守り、逆方向の依存（molecules → organisms）は避ける
   - 新規コンポーネントの作成時は、必ずこの構造に従うこと

2. **App Routerの活用**

   - `src/app/`以下にNext.jsのApp Routerパターンを採用
   - 各ページは`page.tsx`として実装し、共通レイアウトは`layout.tsx`で管理
   - エラー処理は`error.tsx`、ローディング状態は`loading.tsx`で統一的に実装

3. **型定義の集中管理**
   - `src/types/`ディレクトリで型定義を集中管理
   - コンポーネント間で共有される型は共通モジュールとして定義
   - 型安全性を確保するため、`any`型の使用を避け、明示的な型定義を徹底

## コーディングパターンの記憶

1. **条件付きレンダリングのパターン**

   ```tsx
   {
     isTopPage ? <NavigationMenu /> : <BackButton />;
   }
   ```

   - 条件によって表示/非表示を切り替える場合は、上記のパターンを使用
   - 特にナビゲーションメニューはトップページでのみ表示するルールを採用

2. **スタイリングの一貫性**

   ```tsx
   <div className={cn(
     "bg-gray-900/80 p-4 rounded-lg",
     "hover:bg-gray-800/90 transition-colors",
     className
   )}>
   ```

   - Tailwindのユーティリティクラスを`cn()`関数でグループ化
   - 背景色は暗めの色調、アクセント色は青系統を基本とする
   - コンポーネント間で視覚的な一貫性を保つよう注意

3. **エラーハンドリングパターン**

   ```tsx
   try {
     // 処理
   } catch (error) {
     console.error("エラーが発生しました:", error);
     return <ErrorComponent message="エラーが発生しました" />;
   }
   ```

   - エラー発生時は適切なエラーメッセージを表示
   - ユーザーフレンドリーなエラー表示を心がける

4. **データフェッチングパターン**
   ```tsx
   // サーバーコンポーネントでのデータフェッチ
   const data = await fetch("/api/data", { next: { revalidate: 3600 } }).then(
     (res) => res.json()
   );
   ```
   - 可能な限りサーバーコンポーネントでデータフェッチングを実施
   - 適切なキャッシュ戦略を設定

## コンポーネント設計と構造に関する記憶

1. **コンポーネントの標準ディレクトリ構造**

   - 各コンポーネントは以下の標準ディレクトリ構造を厳格に遵守すること:

   ```
   src/components/カテゴリ/
     └── ComponentName/
         ├── ComponentName.tsx    # コンポーネント実装
         ├── ComponentName.test.tsx    # テスト
         └── index.ts             # エクスポート定義
   ```

   - この構造により、関連ファイルが一箇所に集約され、コンポーネントの管理が容易になる
   - インデックスファイルを使用することで、インポートパスをシンプルに保ちながら内部実装の詳細を隠蔽できる
   - 新規コンポーネントの作成時は、必ずこの構造に従うこと

2. **コンポーネントのエクスポートとインポートの標準パターン**

   - コンポーネントファイル内では名前付きエクスポートとデフォルトエクスポートの両方を提供

   ```tsx
   export const ComponentName = () => {
     /* ... */
   };
   export default ComponentName;
   ```

   - index.tsファイルでは両方のエクスポート方法をサポート

   ```tsx
   export { default, ComponentName } from "./ComponentName";
   ```

   - これにより、利用側での柔軟なインポート方法を実現

   ```tsx
   // 両方とも機能する
   import { ComponentName } from "@/components/atoms/ComponentName";
   import ComponentName from "@/components/atoms/ComponentName";
   ```

3. **コンポーネント実装の基本ルール**

   - 新規コンポーネント作成時の手順：

     1. 適切なカテゴリディレクトリの選択（atoms, molecules, organisms, templates, pages）
     2. 標準ディレクトリ構造の作成
     3. 実装ファイル、テストファイル、インデックスファイルの作成
     4. テストの実装と実行
     5. リントチェックの実行（`yarn lint`）
     6. 最終テストとビルド検証の実行

   - 実装時の注意点：
     - インポートパスは`@/components/カテゴリ/ComponentName`の形式を使用
     - 型定義は明示的に行い、`any`型の使用を避ける
     - 未使用インポートは削除
     - コンポーネント間の依存関係はアトミックデザインの階層構造に従う

## テスト関連の記憶

1. **テストのモック実装と管理**

   - コンポーネントテストにおけるモック戦略:
     - 外部ライブラリ（アイコン、UIコンポーネント、フレームワーク機能）は一元的にモック
     - `jest.setup.js`でモックの基本設定を集中管理
     - 複雑なコンポーネントは階層構造を保持しつつ簡略化したモックを作成
   - 共通モックパターン:

     - アイコンコンポーネント: `data-testid`属性を持つ単純なspan要素
     - Framer Motionコンポーネント: 対応するHTML要素の単純版
     - 共通UIコンポーネント: 基本スタイルと`data-testid`を持つ要素
     - Next.jsフック: 適切な返り値を持つモック関数

   - モック管理の注意点:
     - 新しいライブラリやコンポーネントを追加した場合は必要なモックも追加
     - テスト失敗の多くはモックの不足に起因するため、モック設定を優先的に確認
     - モックの実装は実際のコンポーネント動作に近い挙動を再現

2. **テストの実行と安定性の確保**

   - テスト実行の基本ルール:
     - コンポーネント変更後は対応するテストを必ず実行
     - 構造変更後は全テストを実行して影響範囲を確認
     - ビルド前の全テスト実行による品質保証
   - テスト安定性向上の手法:

     - 要素取得は`data-testid`属性を優先使用
     - 非同期処理テストでは`waitFor`や`findBy*`クエリを使用
     - 複雑なテキスト検証は正規表現による部分一致を活用
     - セレクタは安定性の高い方法（id > role > class）を優先

   - テスト修正の優先順位:
     1. コンポーネントの意図と実装が正しい場合はテストを修正
     2. テストの期待値が正しい場合はコンポーネントを修正
     3. 両方に問題がある場合は設計から見直し

3. **コンポーネント移動に伴うテスト対応**

   - テストファイルの移動と更新の基本手順:
     1. テストファイルのディレクトリ移動
     2. インポートパスの更新
     3. `yarn test <テストファイル名>`による動作確認
     4. 失敗時はモック、アサーション、セレクタの見直し
   - 移動後の検証方法:
     - 個別テストの成功確認
     - コンポーネント間の相互作用を確認するための統合テスト
     - 全テスト実行によるシステム全体への影響確認

## リントチェックとコード品質の維持

1. **リントチェックの重要性と実行タイミング**

   - コード品質保証のためのリントチェック実行ポイント:
     - コンポーネント実装・修正後
     - コンポーネント移行作業の完了時
     - テスト実装・修正後
     - プルリクエスト作成前
     - ビルド実行前
   - リントチェックの基本コマンドと対象:
     ```bash
     yarn lint  # すべてのソースコードとテストファイルをチェック
     ```
   - リントチェックが特に重要な状況:
     - TypeScript型定義の問題検出
     - 未使用インポートや変数の発見
     - コードフォーマットの統一
     - 潜在的なバグの検出

2. **リントチェックを忘れやすい状況と対策**

   - リントチェックが見落とされやすい状況:
     - コンポーネント移行作業時（テスト実行に注力するあまりリントチェックを忘れる）
     - 小規模の修正時（影響が少ないと誤認する）
     - 急ぎのタスク対応時（品質チェックを後回しにする）
     - テストファイル修正時（本番コードほど重視しない傾向）
   - 効果的な対策:
     - コンポーネント移行チェックリストに「リントチェック」を明示的に追加
     - CIパイプラインでのリントチェック自動化
     - エディタ設定でのファイル保存時自動リント実行
     - テスト実行後に自動的にリントチェックを行うスクリプトの導入
   - `Footer.test.tsx`の事例にみる教訓:
     - テストファイルでも`any`型の使用は避け、具体的な型定義に置き換える
     - 例: `any`型の代わりに `{ children: React.ReactNode; [key: string]: unknown }` を使用
     - テストが成功していても型安全性が確保されていない可能性を認識

3. **コード品質向上のためのプラクティス**

   - 未使用インポートの削除:
     - 未使用インポートはバンドルサイズとパフォーマンスに悪影響
     - 定期的なリントチェックで検出と削除を習慣化
     - リファクタリング後は特に注意して確認
   - TypeScript互換性の管理:

     - 現環境ではTypeScript 5.7.3と@typescript-eslint/typescript-estreeの互換性に注意
     - サポート範囲は>=4.3.5 <5.4.0で、将来的な調整が必要
     - パッケージ更新時は互換性の確認を優先

   - 型安全性の確保:
     - `any`型の使用を避け、具体的な型定義を推奨
     - 特に外部ライブラリとの連携部分は明示的な型定義を提供
     - インターフェースと型エイリアスを適切に使い分け

## デプロイ関連の記憶

1. **Vercelデプロイ前のチェックリスト**

   - 品質確認コマンド:

     ```bash
     # 型チェック
     yarn tsc --noEmit

     # リントチェック
     yarn lint

     # テスト実行
     yarn test

     # ビルドテスト
     yarn build
     ```

   - チェックポイント:
     - 未使用の変数やインポートの削除
     - 型エラーの解消
     - テストの全件成功
     - ビルドの正常完了

2. **環境設定ファイルの管理**

   - 使用する設定ファイル形式:
     - Next.js設定: `next.config.js`
     - ESLint設定: `.eslintrc.json`
     - Jest設定: `jest.config.js`
   - 設定ファイル更新時の注意点:
     - パッケージのバージョン互換性確認
     - 環境変数の設定検証
     - ローカルとCI環境での一貫性確保

## 特定の実装に関する記憶

1. **ナビゲーションとヘッダー**

   - ヘッダーのGitHubアイコンとテーマトグルは、すべてのページで表示
   - ナビゲーションメニューはトップページ（`pathname === "/"`）でのみ表示
   - モバイルメニューボタンもトップページでのみ表示
   - スクロール検出機能によるヘッダーの背景色変更

2. **ホームページ構成**

   - 複数のセクション（About, Blogs, Skills, Contact）で構成
   - スクロールインジケーターによるユーザー誘導
   - 各セクションは視覚的に区別されつつも全体的な一貫性を保持

3. **コンタクトセクション**

   - Contactコンポーネント（organism）がセクションのレイアウトと装飾を担当
   - ContactFormコンポーネント（organism）がフォーム機能を提供
   - 明確な責任分担：Contactはレイアウトと視覚的要素、ContactFormはフォーム機能と状態管理
   - アニメーションによる視覚的な魅力の向上
   - Formspreeを使用したフォーム送信機能
   - 状態管理による送信プロセスの視覚的フィードバック
   - エラーハンドリングとユーザーフレンドリーなメッセージ表示
   - 環境変数による柔軟な設定

4. **アニメーション実装**
   - Framer Motionを使用して滑らかなアニメーションを実装
   - アクセシビリティに配慮し、`prefers-reduced-motion`に対応
   - スクロールアニメーションには`useInView`フックを使用
   - ホバーアニメーションには`whileHover`プロパティを使用
   - クリックアニメーションには`whileTap`プロパティを使用

## 開発中に遭遇した問題と解決策

1. **未使用インポートによるビルドエラー**

   - 問題: 未使用のインポートがビルド時にエラーを引き起こした
   - 解決策: デプロイ前に`yarn lint`と`yarn tsc --noEmit`を実行して未使用インポートを検出

2. **アイコンモックの不足によるテスト失敗**

   - 問題: 新しいアイコンを追加した際にテストが失敗
   - 解決策: `jest.setup.js`に新しいアイコンのモックを追加

3. **アトミックデザインの階層構造の逆転**

   - 問題: Contactコンポーネント（molecule）がContactFormコンポーネント（organism）を使用しており、階層構造が逆転
   - 解決策: Contactコンポーネントをmoleculesからorganismsに移動し、適切な階層構造を維持
   - 学び: コンポーネントの分類は責任範囲と複雑さに基づいて行い、依存関係の方向性を常に意識する

4. **コンポーネントディレクトリ構造変更後のインポートパスエラー**
   - 問題: コンポーネントをディレクトリ構造に移行した後、インポートパスが機能しなくなった
   - 解決策: index.tsファイルでコンポーネントの名前付きエクスポートとデフォルトエクスポートの両方を再エクスポート
   - 学び: コンポーネントのエクスポート方法とインポート方法の一貫性を確保することが重要

## マークダウン処理と目次生成に関する記憶

1. **日本語を含むマークダウン見出しのID生成**

   - 日本語を含む見出しからID生成する際の問題:
     - 英数字とハイフン以外をすべて削除する正規表現 `/[^\w\-]+/g` は日本語文字をすべて削除してしまう
     - これにより空のIDが生成され、目次の機能が壊れてしまう
   - 正しいID生成の実装パターン:

   ```typescript
   // マークダウンからHTMLに変換する際のID生成
   const id = text
     .toLowerCase()
     .trim()
     .replace(/[\s\t\n]+/g, "-") // 空白文字をハイフンに置換
     .replace(/[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g, "") // 特殊記号を削除
     .replace(/-+/g, "-") // 連続するハイフンを単一のハイフンに
     .replace(/^-|-$/g, ""); // 先頭と末尾のハイフンを削除

   // ID生成が空文字列になる場合のフォールバック
   const finalId =
     id ||
     `heading-${level}-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
   ```

   - このパターンは以下の特徴を持つ:
     - 日本語の文字を保持したまま特殊記号のみを削除
     - 空白文字のみをハイフンに変換
     - 連続するハイフンを単一のハイフンに正規化
     - 先頭と末尾のハイフンを削除してクリーンなIDを生成
     - 万が一空文字列になった場合のフォールバックを用意

2. **サーバーサイドおよびクライアントサイドの一貫したID生成**

   - マークダウンからHTMLへの変換（サーバーサイド）とTableOfContents（クライアントサイド）の両方で同じID生成ロジックを使用することが重要
   - この一貫性により以下の問題を防止:
     - 目次のリンククリック時にスクロールが機能しない
     - 自動スクロール追従が正しく動作しない
     - 目次項目と実際の見出しの不一致

3. **目次コンポーネントの実装パターン**

   - IntersectionObserverの設定:

   ```typescript
   const observerOptions = {
     rootMargin: "-80px 0px -70% 0px",
     threshold: [0.1, 0.5, 0.9],
   };
   ```

   - このパターンは以下の特徴を持つ:

     - 上部マージンは固定ヘッダーに対応するため負の値を指定
     - 下部マージンは大きな負の値で、画面上部に来た時点で活性化されるように設定
     - 複数の閾値を設定することで、より正確な検出が可能

   - アクティブ見出しのスタイル:

   ```tsx
   <a
     href={`#${heading.id}`}
     className={cn(
       "block py-1.5 border-l-2 pl-3 hover:text-primary transition-colors",
       activeId === heading.id
         ? "border-primary text-primary font-medium bg-primary/5"
         : "border-transparent text-muted-foreground"
     )}
   >
   ```

   - このパターンは以下の特徴を持つ:
     - 左ボーダーによる視覚的な強調
     - アクティブ時の背景色変更による視認性向上
     - テキスト色とフォントウェイトの変更による強調
     - hovr状態との視覚的な区別

4. **マークダウン処理のデバッグと保守**

   - 開発時のデバッグを容易にするパターン:

   ```typescript
   // 開発環境でのみデバッグ出力を有効化
   const DEBUG = process.env.NODE_ENV === "development";

   // デバッグログの出力
   if (DEBUG) {
     console.log("マークダウン内の見出し行:", headingLines);
     console.log("HTML内の見出しタグ:", headingTags);
     console.log("生成されたID:", idGeneratedHeadings);
   }
   ```

   - このパターンは以下の特徴を持つ:
     - 開発環境でのみログが出力され、本番環境ではログが抑制される
     - 必要な情報だけを選別して出力し、コンソールの肥大化を防ぐ
     - 異なる処理段階での出力を比較分析できるように情報を整理
     - 将来のデバッグのために重要な箇所にログポイントを残す

## 次のステップ

1. **コンポーネントドキュメントの体系化**

   - 各コンポーネントのAPI仕様と利用例の文書化
   - 型定義とプロパティの詳細説明
   - コンポーネント間の関係性と依存関係の可視化

2. **テスト戦略の強化**

   - テストカバレッジの向上と監視の仕組み導入
   - 単体テストの拡充と統合テストの追加
   - テスト自動化の拡充

3. **パフォーマンス最適化**

   - Webバイタルの計測と最適化
   - 画像・アセットの最適化
   - レンダリングパフォーマンスの向上

4. **アクセシビリティの向上**

   - アクセシビリティ監査の実施
   - キーボード操作性の改善
   - スクリーンリーダー対応の強化

5. **ブログコンテンツの充実**

   - 新しい記事の作成と既存記事の更新
   - 関連するキーワードやトピックに基づく関連記事の紹介
   - コミュニティとのやりとりの促進

6. **SEO対策の強化**

   - 検索エンジン最適化（SEO）の実施
   - キーワードの選択と埋め込み
   - サイトの構造とコンテンツの整理

7. **パフォーマンス最適化の継続**

   - 既存の最適化手法の継続と改善
   - 新しいツールやライブラリの導入
   - ユーザーのフィードバックに基づく継続的な改善

8. **UIデザインの微調整と改善**

   - 既存のデザインの見直しと改善
   - 新しいデザイン要素の導入
   - ユーザーのフィードバックに基づく継続的な改善
