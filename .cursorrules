Next.js App Router with React, Shadcn UI, Radix UI, and Tailwind
ポートフォリオサイト用のコーディングガイドライン

1. ファイル構造:
- App Routerディレクトリ構造（`src/app/`フォルダ）を使用
- 再利用可能なコンポーネントは`src/components/`ディレクトリに配置
- ルートコンポーネントには`page.tsx`を使用
- 共有レイアウトには`layout.tsx`を使用
- ローディング状態には`loading.tsx`を使用
- エラー境界には`error.tsx`を使用

2. コンポーネント設計:
- アトミックデザインパターンを採用
  - atoms: 最小単位のUI要素
  - molecules: 複数のatomsを組み合わせた要素
  - organisms: 複数のmoleculesを組み合わせた機能的なセクション
  - templates: ページのレイアウト構造
  - pages: 完全なページコンポーネント
- 共通コンポーネントの抽出と再利用を積極的に行う
- 同じパターンのコードは共通化して重複を避ける

3. React と TypeScript:
- 関数コンポーネントとフックを使用
- デフォルトではサーバーコンポーネントを優先し、必要に応じて'use client'ディレクティブを使用
- ES6+構文と機能を使用
- TypeScriptの型安全性を活用
- 明示的な型定義を行い、インターフェースを適切に設計する

4. Shadcn UI と Radix UI:
- Shadcn UIコンポーネントは`@/components/ui`からインポート
- 複雑なインタラクティブコンポーネントにはRadix UIプリミティブを使用
- 提供された設定オプションを使用してShadcn UIコンポーネントをカスタマイズ

5. Tailwind CSS:
- スタイリングにはTailwindユーティリティクラスを使用
- 再利用可能なスタイルにはCSSモジュールの`@apply`ディレクティブを活用
- 条件付きクラス名には`cn()`ユーティリティ関数を使用
- 一貫したカラーパレットを使用（ダークテーマベース）
  - 背景色: 暗めの色調（bg-gray-900/80, bg-gray-900など）
  - アクセント色: 青系統（text-blue-400, text-blue-300など）
  - テキスト色: 明るめの色調（text-white, text-gray-300など）
  - 強調表示: グラデーション（bg-gradient-to-r from-blue-400 to-purple-400）

6. データフェッチング:
- 可能な限りサーバーコンポーネントでデータフェッチングを行う
- React SuspenseとNext.jsの`loading.tsx`ファイルを使用してローディング状態を実装
- サーバーコンポーネントでは適切なキャッシュオプションを持つ`fetch()`を使用

7. ルーティング:
- App Routerのファイルベースルーティングを活用
- クライアントサイドナビゲーションにはLinkコンポーネントを使用
- 動的ルートには括弧構文を使用（例：[id].tsx）

8. 状態管理:
- ローカル状態にはReactフック（useState, useReducer）を使用
- サーバーコンポーネントでのサーバーサイド状態管理を検討
- 必要に応じてグローバル状態にはコンテキストを使用

9. パフォーマンス:
- 動的インポートによるコード分割を実装
- 最適化された画像にはImageコンポーネントを使用
- Next.jsの組み込み最適化を活用（自動静的最適化など）

10. アクセシビリティ:
- Radix UIの組み込みアクセシビリティ機能を活用
- セマンティックなHTML要素を使用
- 必要に応じて適切なARIA属性を実装
- 適切なコントラスト比を確保

11. アニメーションとインタラクション:
- Framer Motionを使用して滑らかなアニメーションを実装
- 共通のアニメーション設定を変数として定義して再利用
- ホバーやタップ時の視覚的フィードバックを提供

12. コード品質とリファクタリング:
- DRY（Don't Repeat Yourself）原則に従う
- 適切なエラー処理とフォールバックUIを実装
- 型安全性のためにTypeScriptを使用
- コンポーネントとユーティリティ関数のユニットテストを作成
- 定期的にコードをリファクタリングして可読性と保守性を向上
- 共通パターンは抽出して再利用可能なコンポーネントやフックに変換

13. デザインシステム:
- 一貫したデザイン言語を使用
- ダークテーマをベースとした配色
- 青と紫のグラデーションをアクセントとして使用
- カードベースのレイアウトに統一感を持たせる
- 適切な余白とコントラストで可読性を確保

14. もしあなたがLLMなら
- 着手前に既存のソースコードを読み込んでください
- ソースコードを全て読み込んだら次にこれから実装するプランを考えそのプランが正しいかを確認してください
- タスクが細分化されていないと判断したら必ずタスクを細分化しプランを再考してください
- そのプランが正しいと判断したらコードを実装してください
- コードを実装したら必ずそのコードが正しいかを確認してください
- コード実装し終えた後にコードが正しいものであってもリファクタリングの余地がある場合はリファクタリングを行ってください
- 特にコードの重複がある場合や一般化できる場合は必ず共通化を行ってください
- このガイドラインを必ず守ってください
- 私からの指摘があればそれに従い、その指摘事項を繰り返し指摘されないように.cursorrulesを更新してナレッジを貯めていってください
- 既存のコードベースの構造とスタイルを尊重し、一貫性を保つようにしてください
- 新しいコードを追加する際は、既存のパターンに従ってください
- 型の互換性に特に注意し、型エラーが発生しないようにしてください
- 翻訳キーが欠けている場合は、すべての言語ファイルに追加してください
- コンポーネント間のデータの受け渡しでは、適切なpropsの型定義を行ってください
- 条件付きレンダリングを実装する際は、オプショナルな値の存在チェックを必ず行ってください
- パフォーマンスに影響を与える可能性のある変更は、その影響を評価してから実装してください
- 複雑なロジックには適切なコメントを追加し、理解しやすくしてください
- UIコンポーネントの変更は、モバイルとデスクトップの両方で適切に表示されることを確認してください
- アニメーションを追加する場合は、アクセシビリティに配慮し、必要に応じて`prefers-reduced-motion`に対応してください
- 常に日本語で応答し、技術的な説明も日本語で行ってください
- コンテンツの変更は最小限に抑え、機能的な変更のみを行ってください
- 既存のコンテンツ（テキスト、画像パス、リンク先など）は変更せず、構造やロジックの修正に集中してください
- 新しい機能を追加する場合は、既存の機能と調和するように設計してください
- 既存のデザインテーマ（色、フォント、スペーシングなど）を維持してください
- コードの最適化を行う場合でも、元の機能や挙動を変更しないようにしてください
- 変更の影響範囲を明確に把握し、副作用が最小限になるようにしてください
- 実装前に変更の目的と方法を明確に説明し、承認を得てから進めてください
- 複数の解決策がある場合は、それぞれのメリット・デメリットを説明し、最適な選択肢を提案してください
- エラーが発生した場合は、根本原因を特定し、一時的な対処ではなく恒久的な解決策を提案してください
- 型エラーを解決する際は、型の互換性を確保するだけでなく、型安全性も維持してください
- バグ修正の際は、同様の問題が他の箇所でも発生していないか確認してください
- 問題の再現手順を明確に説明し、修正後にその問題が解決したことを確認してください
- 複雑な問題に対しては、段階的なアプローチを取り、各ステップでの進捗を確認してください
- 既存のコードに問題を見つけた場合は、修正だけでなく、なぜその問題が発生したのかも説明してください
- パフォーマンスの問題を解決する際は、改善前後の状態を比較できるようにしてください
- セキュリティに関わる問題は最優先で対処し、潜在的なリスクも評価してください

15. 型定義の強化と集中管理:
- 型定義は`src/types`ディレクトリで集中管理し、ドメイン別に整理する
  ```
  src/types/
    ├── common.ts      # 共通の型定義
    ├── api/           # API関連の型定義
    ├── components/    # コンポーネント固有の型定義
    └── pages/         # ページ固有の型定義
  ```
- インターフェースとタイプエイリアスを適切に使い分ける
- 再利用可能な型は共通モジュールに定義し、インポートして使用する
- 型定義には適切なJSDocコメントを付与し、使用方法を明確にする

16. コンポーネントのドキュメント化:
- Storybookを導入し、UIコンポーネントのドキュメント化と視覚的テストを実施
  ```
  src/components/
    └── atoms/Button/
        ├── Button.tsx
        ├── Button.stories.tsx  # ストーリーブック定義
        └── Button.test.tsx     # テスト
  ```
- 各コンポーネントには適切なJSDocコメントを付与し、使用方法と期待される動作を明記する
- コンポーネントのプロパティには詳細な型定義とデフォルト値を設定する
- 複雑なコンポーネントには使用例を含めたドキュメントを作成する

17. カスタムフックの強化:
- 共通のロジックをカスタムフックとして抽出し、テスト可能な形で実装
  ```
  src/hooks/
    ├── useForm/
    │   ├── useForm.ts
    │   └── useForm.test.ts
    ├── useLocalStorage/
    │   ├── useLocalStorage.ts
    │   └── useLocalStorage.test.ts
    └── index.ts  # すべてのフックをエクスポート
  ```
- フックは単一責任の原則に従い、一つの機能に特化させる
- 再利用可能なフックは汎用的に設計し、型パラメータを活用して柔軟性を持たせる
- フックのテストは実際のユースケースを想定したシナリオで作成する

18. 国際化（i18n）の体系化:
- i18nの構造をドメイン別に整理し、効率的に管理
  ```
  src/i18n/
    ├── locales/
    │   ├── ja/
    │   │   ├── common.json
    │   │   ├── home.json
    │   │   └── about.json
    │   └── en/
    │       ├── common.json
    │       ├── home.json
    │       └── about.json
    └── config.ts
  ```
- 翻訳キーは階層構造を持たせ、名前空間を活用して整理する
- 動的な値を含む翻訳には型安全な補間を使用する
- 翻訳の欠落を検出するためのツールを導入する

19. 自動テストの強化:
- 単体テスト、統合テスト、E2Eテストの3層構造でテストを実装
  ```
  src/
    ├── __tests__/
    │   ├── unit/      # 単体テスト
    │   ├── integration/ # 統合テスト
    │   └── e2e/       # E2Eテスト
    └── components/
        └── atoms/Button/
            └── __tests__/
                └── Button.test.tsx  # コンポーネント単位のテスト
  ```
- テストカバレッジの目標を設定し、CI/CDパイプラインで監視する
- スナップショットテストを活用してUIの変更を検出する
- テストデータは固定値ではなくファクトリー関数で生成し、柔軟性を持たせる
- モックとスタブを適切に使い分け、テストの独立性を確保する

20. パフォーマンス最適化の体系化:
- パフォーマンス計測と最適化のための仕組みを導入
  ```
  src/lib/
    └── performance/
        ├── metrics.ts  # パフォーマンス計測用ユーティリティ
        └── optimizations.ts  # 最適化用ユーティリティ
  ```
- Webバイタルを継続的に計測し、改善点を特定する
- 画像やアセットの最適化を自動化する
- コンポーネントのメモ化戦略を明確にし、不要な再レンダリングを防ぐ
- サーバーサイドレンダリングとクライアントサイドレンダリングの適切なバランスを取る

21. エラーハンドリングの統一:
- エラーハンドリングの方針を統一し、共通のエラーコンポーネントとロジックを実装
  ```
  src/lib/
    └── errors/
        ├── ErrorBoundary.tsx  # エラー境界コンポーネント
        ├── errorHandlers.ts   # エラーハンドリングロジック
        └── errorTypes.ts      # エラー型定義
  ```
- エラーの種類に応じた適切な対応策を実装する
- ユーザーフレンドリーなエラーメッセージを表示する
- エラーログを収集し、分析するための仕組みを導入する
- 予期せぬエラーに対するフォールバックUIを用意する

22. 設定の集中管理:
- アプリケーション全体の設定を一箇所で管理
  ```
  src/config/
    ├── constants.ts    # 定数
    ├── theme.ts        # テーマ設定
    ├── routes.ts       # ルート定義
    └── features.ts     # 機能フラグ
  ```
- 環境変数は型安全に管理し、バリデーションを実施する
- 機能フラグを導入し、段階的なリリースを可能にする
- 設定値の変更履歴を管理し、トレーサビリティを確保する

23. コードジェネレーターの導入:
- 新しいコンポーネントやページを作成するためのコードジェネレーターを導入
  ```
  scripts/
    └── generators/
        ├── component.js  # コンポーネント生成
        ├── page.js       # ページ生成
        └── hook.js       # フック生成
  ```
- 生成されるコードはプロジェクトの規約に準拠したものにする
- テンプレートはカスタマイズ可能にし、プロジェクトの進化に合わせて更新する
- 生成コマンドはnpm/yarnスクリプトとして提供し、使いやすくする

24. コードレビューチェックリストの作成:
- コードレビュー時に確認すべき項目をチェックリスト化
  ```
  docs/
    └── code-review-checklist.md
  ```
- パフォーマンス、アクセシビリティ、セキュリティなどの観点を含める
- 自動化できる項目はlinterやCIツールで検証する
- レビュープロセスを標準化し、効率的なフィードバックを促進する
